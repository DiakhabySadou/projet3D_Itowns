'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _OBB2 = require('../../../Renderer/ThreeExtended/OBB');

var _OBB3 = _interopRequireDefault(_OBB2);

var _Coordinates = require('../../Geographic/Coordinates');

var _Coordinates2 = _interopRequireDefault(_Coordinates);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PanoramaTileBuilder(ratio) {
    this.tmp = {
        coords: new _Coordinates2.default('EPSG:4326', 0, 0),
        position: new THREE.Vector3(),
        normal: new THREE.Vector3(0, 0, 1)
    };

    if (!ratio) {
        throw new Error('ratio must be defined');
    }
    if (ratio === 2) {
        this.equirectangular = true;
        this.radius = 100;
    } else {
        this.equirectangular = false; // cylindrical proj
        this.height = 200;
        this.radius = ratio * this.height / (2 * Math.PI);
    }
}

PanoramaTileBuilder.prototype.constructor = PanoramaTileBuilder;

// prepare params
// init projected object -> params.projected
PanoramaTileBuilder.prototype.Prepare = function (params) {
    if (this.equirectangular) {
        params.projected = {
            theta: 0,
            phi: 0,
            radius: this.radius
        };
    } else {
        params.projected = {
            theta: 0,
            radius: this.radius,
            y: 0
        };
    }
};

PanoramaTileBuilder.prototype.Center = function (params) {
    this.Prepare(params);

    this.uProjecte(0.5, params);
    this.vProjecte(0.5, params);

    params.center = this.VertexPosition(params).clone();

    return params.center;
};

// get position 3D cartesian
PanoramaTileBuilder.prototype.VertexPosition = function (params) {
    if (this.equirectangular) {
        this.tmp.position.setFromSpherical(params.projected);
    } else {
        this.tmp.position.setFromCylindrical(params.projected);
    }
    var swap = this.tmp.position.y;
    this.tmp.position.y = this.tmp.position.z;
    this.tmp.position.z = this.equirectangular ? -swap : swap;

    return this.tmp.position;
};

// get normal for last vertex
PanoramaTileBuilder.prototype.VertexNormal = function () {
    return this.tmp.position.clone().negate().normalize();
};

// coord u tile to projected
PanoramaTileBuilder.prototype.uProjecte = function (u, params) {
    // both (theta, phi) and (y, z) are swapped in setFromSpherical
    params.projected.theta = THREE.Math.lerp(params.extent.west(_Coordinates.UNIT.RADIAN), params.extent.east(_Coordinates.UNIT.RADIAN), u);
};

// coord v tile to projected
PanoramaTileBuilder.prototype.vProjecte = function (v, params) {
    if (this.equirectangular) {
        params.projected.phi = Math.PI * 0.5 + THREE.Math.lerp(params.extent.south(_Coordinates.UNIT.RADIAN), params.extent.north(_Coordinates.UNIT.RADIAN), v);
    } else {
        params.projected.y = this.height * THREE.Math.lerp(params.extent.south(), params.extent.north(), v) / 180;
    }
};

// get oriented bounding box of tile
PanoramaTileBuilder.prototype.OBB = function (params) {
    if (this.equirectangular) {
        var pts = [];
        //      0---1---2
        //      |       |
        //      7   8   3
        //      |       |
        //      6---5---4
        var uvs = [[0, 0.0], [0.5, 0], [1, 0.0], [1, 0.5], [1, 1.0], [0.5, 1], [0, 1.0], [0, 0.5], [0.5, 0.5]];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = (0, _getIterator3.default)(uvs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var uv = _step.value;

                this.uProjecte(uv[0], params);
                this.vProjecte(uv[1], params);
                pts.push(this.VertexPosition(params).clone());
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        return _OBB3.default.cardinalsXYZToOBB(pts, params.extent.center().longitude(_Coordinates.UNIT.RADIAN), false);
    } else {
        // 3 points: corners + center
        var _pts = [];
        this.uProjecte(0.5, params);
        this.vProjecte(0.5, params);
        _pts.push(this.VertexPosition(params).clone());
        this.uProjecte(0, params);
        this.vProjecte(0, params);
        _pts.push(this.VertexPosition(params).clone());
        this.uProjecte(1, params);
        this.vProjecte(1, params);
        _pts.push(this.VertexPosition(params).clone());

        var direction = params.center.clone();
        direction.z = 0;
        direction.normalize();

        var diffExtent = new THREE.Vector3().subVectors(_pts[2], _pts[1]);
        var height = diffExtent.z;
        diffExtent.z = 0;

        var length = diffExtent.length();

        var diff = new THREE.Vector3().subVectors(params.center, _pts[1]);
        diff.z = 0;
        var thickness = diff.dot(direction);

        var min = new THREE.Vector3(-length * 0.5, -height * 0.5, -thickness * 0.5);
        var max = new THREE.Vector3(length * 0.5, height * 0.5, thickness * 0.5);

        var translate = new THREE.Vector3(0, 0, thickness * -0.5);
        return new _OBB3.default(min, max, direction, translate);
    }
};

exports.default = PanoramaTileBuilder;