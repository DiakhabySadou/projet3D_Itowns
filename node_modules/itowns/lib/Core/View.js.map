{"version":3,"sources":["../../src/Core/View.js"],"names":["View","crs","viewerDiv","options","Error","referenceCrs","engine","renderer","domElement","mainLoop","scene","scene3D","autoUpdate","camera","gfxEngine","getWindowSize","x","y","_frameRequesters","_layers","window","addEventListener","newSize","clientWidth","clientHeight","onWindowResize","notifyChange","onAfterRender","_changeSources","prototype","constructor","_syncGeometryLayerVisibility","layer","view","object3d","visible","threejsLayer","camera3D","layers","enable","disable","_preprocessLayer","provider","nlayer","id","tmp","updateStrategy","type","tileInsideLimit","bind","tileTextureCount","whenReady","getUniqueThreejsLayer","providerPreprocessing","resolve","preprocessDataLayer","scheduler","then","ready","changeOpacity","o","material","opacity","undefined","transparent","uniforms","value","traverse","content","addLayer","parentLayer","duplicate","getLayers","l","length","getProtocolProvider","protocol","extent","attach","update","preUpdate","push","parent","add","needsRedraw","changeSource","scheduleViewUpdate","filter","result","geometryLayer","_attachedLayers","attached","addFrameRequester","frameRequester","removeFrameRequester","splice","indexOf"],"mappings":"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","file":"View.js","sourcesContent":["/* global window, requestAnimationFrame */\nimport { Scene, EventDispatcher, Vector2 } from 'three';\nimport Camera from '../Renderer/Camera';\nimport MainLoop from './MainLoop';\nimport c3DEngine from '../Renderer/c3DEngine';\nimport { STRATEGY_MIN_NETWORK_TRAFFIC } from './Layer/LayerUpdateStrategy';\nimport { GeometryLayer, Layer, defineLayerProperty } from './Layer/Layer';\nimport Scheduler from './Scheduler/Scheduler';\n\n/**\n * Constructs an Itowns View instance\n *\n * @param {string} crs - The default CRS of Three.js coordinates. Should be a cartesian CRS.\n * @param {HTMLElement} viewerDiv - Where to instanciate the Three.js scene in the DOM\n * @param {Object=} options - Optional properties.\n * @param {?MainLoop} options.mainLoop - {@link MainLoop} instance to use, otherwise a default one will be constructed\n * @param {?(WebGLRenderer|object)} options.renderer - {@link WebGLRenderer} instance to use, otherwise\n * a default one will be constructed. In this case, if options.renderer is an object, it will be used to\n * configure the renderer (see {@link c3DEngine}.  If not present, a new <canvas> will be created and\n * added to viewerDiv (mutually exclusive with mainLoop)\n * @param {?Scene} options.scene3D - {@link Scene} instance to use, otherwise a default one will be constructed\n * @constructor\n * @example\n * // How add gpx object\n * itowns.GpxUtils.load(url, viewer.referenceCrs).then((gpx) => {\n *      if (gpx) {\n *         viewer.scene.add(gpx);\n *      }\n * });\n *\n * viewer.notifyChange(true);\n */\n /* TODO:\n * - remove debug boolean, replace by if __DEBUG__ and checkboxes in debug UI\n */\nfunction View(crs, viewerDiv, options = {}) {\n    if (!viewerDiv) {\n        throw new Error('Invalid viewerDiv parameter (must non be null/undefined)');\n    }\n\n    this.referenceCrs = crs;\n\n    let engine;\n    // options.renderer can be 2 separate things:\n    //   - an actual renderer (in this case we don't use viewerDiv)\n    //   - options for the renderer to be created\n    if (options.renderer && options.renderer.domElement) {\n        engine = new c3DEngine(options.renderer);\n    } else {\n        engine = new c3DEngine(viewerDiv, options.renderer);\n    }\n\n    this.mainLoop = options.mainLoop || new MainLoop(new Scheduler(), engine);\n\n    this.scene = options.scene3D || new Scene();\n    if (!options.scene3D) {\n        this.scene.autoUpdate = false;\n    }\n\n    this.camera = new Camera(\n        this.referenceCrs,\n        this.mainLoop.gfxEngine.getWindowSize().x,\n        this.mainLoop.gfxEngine.getWindowSize().y,\n        options);\n\n    this._frameRequesters = [];\n    this._layers = [];\n\n    window.addEventListener('resize', () => {\n        // If the user gave us a container (<div>) then itowns' size is\n        // the container's size. Otherwise we use window' size.\n        const newSize = new Vector2(viewerDiv.clientWidth, viewerDiv.clientHeight);\n        this.mainLoop.gfxEngine.onWindowResize(newSize.x, newSize.y);\n        this.notifyChange(true);\n    }, false);\n\n    this.onAfterRender = () => {};\n\n    this._changeSources = new Set();\n}\n\nView.prototype = Object.create(EventDispatcher.prototype);\nView.prototype.constructor = View;\n\nconst _syncGeometryLayerVisibility = function _syncGeometryLayerVisibility(layer, view) {\n    if (layer.object3d) {\n        layer.object3d.visible = layer.visible;\n    }\n\n    if (layer.threejsLayer) {\n        if (layer.visible) {\n            view.camera.camera3D.layers.enable(layer.threejsLayer);\n        } else {\n            view.camera.camera3D.layers.disable(layer.threejsLayer);\n        }\n    }\n};\n\nfunction _preprocessLayer(view, layer, provider) {\n    if (!(layer instanceof Layer) && !(layer instanceof GeometryLayer)) {\n        const nlayer = new Layer(layer.id);\n        // nlayer.id is read-only so delete it from layer before Object.assign\n        const tmp = layer;\n        delete tmp.id;\n        layer = Object.assign(nlayer, layer);\n        // restore layer.id in user provider layer object\n        tmp.id = layer.id;\n    }\n\n    if (!layer.updateStrategy) {\n        layer.updateStrategy = {\n            type: STRATEGY_MIN_NETWORK_TRAFFIC,\n        };\n    }\n\n    if (provider) {\n        if (provider.tileInsideLimit) {\n            layer.tileInsideLimit = provider.tileInsideLimit.bind(provider);\n        }\n\n        if (provider.tileTextureCount) {\n            layer.tileTextureCount = provider.tileTextureCount.bind(provider);\n        }\n    }\n\n    if (!layer.whenReady) {\n        if (layer.type == 'geometry' || layer.type == 'debug') {\n            if (!layer.object3d) {\n                // layer.threejsLayer *must* be assigned before preprocessing,\n                // because TileProvider.preprocessDataLayer function uses it.\n                layer.threejsLayer = view.mainLoop.gfxEngine.getUniqueThreejsLayer();\n            }\n        }\n        let providerPreprocessing = Promise.resolve();\n        if (provider && provider.preprocessDataLayer) {\n            providerPreprocessing = provider.preprocessDataLayer(layer, view, view.mainLoop.scheduler);\n            if (!(providerPreprocessing && providerPreprocessing.then)) {\n                providerPreprocessing = Promise.resolve();\n            }\n        }\n\n        // the last promise in the chain must return the layer\n        layer.whenReady = providerPreprocessing.then(() => {\n            layer.ready = true;\n            return layer;\n        });\n    }\n\n    // probably not the best place to do this\n    if (layer.type == 'color') {\n        defineLayerProperty(layer, 'frozen', false);\n        defineLayerProperty(layer, 'visible', true);\n        defineLayerProperty(layer, 'opacity', 1.0);\n        defineLayerProperty(layer, 'sequence', 0);\n    } else if (layer.type == 'elevation') {\n        defineLayerProperty(layer, 'frozen', false);\n    } else if (layer.type == 'geometry' || layer.type == 'debug') {\n        defineLayerProperty(layer, 'visible', true, () => _syncGeometryLayerVisibility(layer, view));\n        _syncGeometryLayerVisibility(layer, view);\n\n        const changeOpacity = (o) => {\n            if (o.material) {\n                // != undefined: we want the test to pass if opacity is 0\n                if (o.material.opacity != undefined) {\n                    o.material.transparent = layer.opacity < 1.0;\n                    o.material.opacity = layer.opacity;\n                }\n                if (o.material.uniforms && o.material.uniforms.opacity != undefined) {\n                    o.material.transparent = layer.opacity < 1.0;\n                    o.material.uniforms.opacity.value = layer.opacity;\n                }\n            }\n        };\n        defineLayerProperty(layer, 'opacity', 1.0, () => {\n            layer.object3d.traverse((o) => {\n                if (o.layer !== layer.id) {\n                    return;\n                }\n                changeOpacity(o);\n                // 3dtiles layers store scenes in children's content property\n                if (o.content) {\n                    o.content.traverse(changeOpacity);\n                }\n            });\n        });\n    }\n    return layer;\n}\n\n/**\n * Options to wms protocol\n * @typedef {Object} OptionsWms\n * @property {Attribution} attribution The intellectual property rights for the layer\n * @property {Object} extent Geographic extent of the service\n * @property {string} name\n * @property {string} mimetype\n */\n\n/**\n * Options to wtms protocol\n * @typedef {Object} OptionsWmts\n * @property {Attribution} attribution The intellectual property rights for the layer\n * @property {string} attribution.name The name of the owner of the data\n * @property {string} attribution.url The website of the owner of the data\n * @property {string} name\n * @property {string} mimetype\n * @property {string} tileMatrixSet\n * @property {Array.<Object>} tileMatrixSetLimits The limits for the tile matrix set\n * @property {number} tileMatrixSetLimits.minTileRow Minimum row for tiles at the level\n * @property {number} tileMatrixSetLimits.maxTileRow Maximum row for tiles at the level\n * @property {number} tileMatrixSetLimits.minTileCol Minimum col for tiles at the level\n * @property {number} tileMatrixSetLimits.maxTileCol Maximum col for tiles at the level\n * @property {Object} [zoom]\n * @property {Object} [zoom.min] layer's zoom minimum\n * @property {Object} [zoom.max] layer's zoom maximum\n */\n\n/**\n * @typedef {Object} NetworkOptions - Options for fetching resources over the\n * network. For json or xml fetching, this object is passed as it is to fetch\n * as the init object, see [fetch documentation]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}.\n * @property {string} crossOrigin For textures, only this property is used. Its\n * value is directly assigned to the crossorigin property of html tags.\n * @property * Same properties as the init parameter of fetch\n */\n\n/**\n * @typedef {Object} LayerOptions\n * @property {string} id Unique layer's id\n * @property {string} type the layer's type : 'color', 'elevation', 'geometry'\n * @property {string} protocol wmts and wms (wmtsc for custom deprecated)\n * @property {string} url Base URL of the repository or of the file(s) to load\n * @property {NetworkOptions} networkOptions Options for fetching resources over network\n * @property {Object} updateStrategy strategy to load imagery files\n * @property {OptionsWmts|OptionsWms} options WMTS or WMS options\n */\n\n/**\n * Add layer in viewer.\n * The layer id must be unique.\n *\n * This function calls `preprocessDataLayer` of the relevant provider with this\n * layer and set `layer.whenReady` to a promise that resolves when\n * the preprocessing operation is done. This promise is also returned by\n * `addLayer` allowing to chain call.\n *\n * @example\n * // Add Color Layer\n * view.addLayer({\n *      type: 'elevation',\n *      id: 'iElevation',\n * });\n *\n * // Example to add an OPENSM Layer\n * view.addLayer({\n *   type: 'color',\n *   protocol:   'wmtsc',\n *   id:         'OPENSM',\n *   fx: 2.5,\n *   customUrl:  'http://b.tile.openstreetmap.fr/osmfr/%TILEMATRIX/%COL/%ROW.png',\n *   options: {\n *       attribution : {\n *           name: 'OpenStreetMap',\n *           url: 'http://www.openstreetmap.org/',\n *       },\n *       tileMatrixSet: 'PM',\n *       mimetype: 'image/png',\n *    },\n * });\n *\n * // Add Elevation Layer and do something once it's ready\n * var layer = view.addLayer({\n *      type: 'elevation',\n *      id: 'iElevation',\n * }).then(() => { .... });\n *\n * // One can also attach a callback to the same promise with a layer instance.\n * layer.whenReady.then(() => { ... });\n *\n * @param {LayerOptions|Layer|GeometryLayer} layer\n * @param {Layer=} parentLayer\n * @return {Promise} a promise resolved with the new layer object when it is fully initialized\n */\nView.prototype.addLayer = function addLayer(layer, parentLayer) {\n    const duplicate = this.getLayers((l => l.id == layer.id));\n    if (duplicate.length > 0) {\n        throw new Error(`Invalid id '${layer.id}': id already used`);\n    }\n\n    const provider = this.mainLoop.scheduler.getProtocolProvider(layer.protocol);\n    if (layer.protocol && !provider) {\n        throw new Error(`${layer.protocol} is not a recognized protocol name.`);\n    }\n    layer = _preprocessLayer(this, layer, provider);\n    layer.whenReady.then(() => {\n        if (parentLayer && !layer.extent) {\n            layer.extent = parentLayer.extent;\n        }\n    });\n    if (parentLayer) {\n        parentLayer.attach(layer);\n    } else {\n        if (typeof (layer.update) !== 'function') {\n            throw new Error('Cant add GeometryLayer: missing a update function');\n        }\n        if (typeof (layer.preUpdate) !== 'function') {\n            throw new Error('Cant add GeometryLayer: missing a preUpdate function');\n        }\n\n        this._layers.push(layer);\n    }\n\n    if (layer.object3d && !layer.object3d.parent && layer.object3d !== this.scene) {\n        this.scene.add(layer.object3d);\n    }\n\n    this.notifyChange(true);\n    return layer.whenReady;\n};\n\n/**\n * Notifies the scene it needs to be updated due to changes exterior to the\n * scene itself (e.g. camera movement).\n * non-interactive events (e.g: texture loaded)\n * @param {boolean} needsRedraw - indicates if notified change requires a full scene redraw.\n * @param {*} changeSource\n */\nView.prototype.notifyChange = function notifyChange(needsRedraw, changeSource) {\n    this._changeSources.add(changeSource);\n    this.mainLoop.scheduleViewUpdate(this, needsRedraw);\n};\n\n/**\n * Get all layers, with an optionnal filter applied.\n * The filter method will be called with 2 args:\n *   - 1st: current layer\n *   - 2nd: (optional) the geometry layer to which the current layer is attached\n * @example\n * // get all layers\n * view.getLayers();\n * // get all color layers\n * view.getLayers(layer => layer.type === 'color');\n * // get all elevation layers\n * view.getLayers(layer => layer.type === 'elevation');\n * // get all geometry layers\n * view.getLayers(layer => layer.type === 'geometry');\n * // get one layer with id\n * view.getLayers(layer => layer.id === 'itt');\n * @param {function(Layer):boolean} filter\n * @returns {Array<Layer>}\n */\nView.prototype.getLayers = function getLayers(filter) {\n    const result = [];\n    for (const geometryLayer of this._layers) {\n        if (!filter || filter(geometryLayer)) {\n            result.push(geometryLayer);\n        }\n        for (const attached of geometryLayer._attachedLayers) {\n            if (!filter || filter(attached, geometryLayer)) {\n                result.push(attached);\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * @typedef {object} FrameRequester\n * @property {Function(dt, updateLoopRestarted)} update - Method that will be called each\n * time the MainLoop updates. This function will be given as parameter the\n * delta (in ms) between this update and the previous one, and whether or not\n * we just started to render again. This update is considered as the \"next\"\n * update if view.notifyChange was called during a precedent update. If\n * view.notifyChange has been called by something else (other micro/macrotask,\n * UI events etc...), then this update is considered as being the \"first\".\n *\n * This means that if a FrameRequester.update function wants to animate\n * something, it should keep on calling view.notifyChange until its task is\n * done.\n *\n * Implementors of FrameRequester.update should keep in mind that this function\n * will be potentially called at each frame, thus care should be given about\n * performance.\n *\n * Typical FrameRequesters are controls, module wanting to animate moves or UI\n * elements etc... Basically anything that would want to call\n * requestAnimationFrame.\n */\n/**\n * Add a frame requester to this view.\n *\n * FrameRequesters can activate the MainLoop update by calling view.notifyChange.\n *\n * @param {FrameRequester} frameRequester\n * @param {Function} frameRequester.update - update will be called at each\n * MainLoop update with the time delta between last update, or 0 if the\n * MainLoop has just been relaunched.\n */\nView.prototype.addFrameRequester = function addFrameRequester(frameRequester) {\n    this._frameRequesters.push(frameRequester);\n};\n\n/**\n * Remove a frameRequester.\n *\n * @param {FrameRequester} frameRequester\n */\nView.prototype.removeFrameRequester = function removeFrameRequester(frameRequester) {\n    this._frameRequesters.splice(this._frameRequesters.indexOf(frameRequester), 1);\n};\n\nexport default View;\n"]}