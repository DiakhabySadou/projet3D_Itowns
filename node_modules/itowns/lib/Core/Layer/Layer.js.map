{"version":3,"sources":["../../../src/Core/Layer/Layer.js"],"names":["defineLayerProperty","layer","propertyName","defaultValue","onChange","existing","set","property","undefined","get","newValue","event","type","previous","new","dispatchEvent","GeometryLayer","id","object3d","Error","isObject3D","_attachedLayers","name","Object","defineProperty","value","writable","postUpdate","prototype","constructor","attach","update","push","detach","count","length","filter","attached","Layer","ImageryLayers","moveLayerToIndex","newIndex","imageryLayers","Math","min","max","oldIndex","sequence","imagery","moveLayerDown","moveLayerUp","m","getColorLayersIdOrderedBySequence","copy","sort","a","b","map","l"],"mappings":"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","file":"Layer.js","sourcesContent":["import { EventDispatcher } from 'three';\n\n/**\n * Fires when layer sequence change (meaning when the order of the layer changes in the view)\n * @event Layer#sequence-property-changed\n * @property new {object}\n * @property new.sequence {number} the new value of the layer sequence\n * @property previous {object}\n * @property previous.sequence {number} the previous value of the layer sequence\n * @property target {Layer} dispatched on layer\n * @property type {string} sequence-property-changed\n*/\n/**\n * Fires when layer opacity change\n * @event Layer#opacity-property-changed\n * @property new {object}\n * @property new.opacity {object} the new value of the layer opacity\n * @property previous {object}\n * @property previous.opacity {object} the previous value of the layer opacity\n * @property target {Layer} dispatched on layer\n * @property type {string} opacity-property-changed\n*/\n/**\n * Fires when layer visibility change\n * @event Layer#visible-property-changed\n * @property new {object}\n * @property new.visible {object} the new value of the layer visibility\n * @property previous {object}\n * @property previous.visible {object} the previous value of the layer visibility\n * @property target {Layer} dispatched on layer\n * @property type {string} visible-property-changed\n*/\n\nexport const defineLayerProperty = function defineLayerProperty(layer, propertyName, defaultValue, onChange) {\n    const existing = Object.getOwnPropertyDescriptor(layer, propertyName);\n    if (!existing || !existing.set) {\n        var property = layer[propertyName] == undefined ? defaultValue : layer[propertyName];\n        Object.defineProperty(layer,\n            propertyName,\n            { get: () => property,\n                set: (newValue) => {\n                    if (property !== newValue) {\n                        const event = { type: `${propertyName}-property-changed`, previous: {}, new: {} };\n                        event.previous[propertyName] = property;\n                        event.new[propertyName] = newValue;\n                        property = newValue;\n                        if (onChange) {\n                            onChange(layer, propertyName);\n                        }\n                        layer.dispatchEvent(event);\n                    }\n                } });\n    }\n};\n\nfunction GeometryLayer(id, object3d) {\n    if (!id) {\n        throw new Error('Missing id parameter (GeometryLayer must have a unique id defined)');\n    }\n    if (!object3d || !object3d.isObject3D) {\n        throw new Error('Missing/Invalid object3d parameter (must be a three.js Object3D instance)');\n    }\n    this._attachedLayers = [];\n\n    if (object3d && object3d.type === 'Group' && object3d.name === '') {\n        object3d.name = id;\n    }\n\n    Object.defineProperty(this, 'object3d', {\n        value: object3d,\n        writable: false,\n    });\n\n    Object.defineProperty(this, 'id', {\n        value: id,\n        writable: false,\n    });\n\n    this.postUpdate = () => {};\n}\n\nGeometryLayer.prototype = Object.create(EventDispatcher.prototype);\nGeometryLayer.prototype.constructor = GeometryLayer;\n\nGeometryLayer.prototype.attach = function attach(layer) {\n    if (!layer.update) {\n        throw new Error(`Missing 'update' function -> can't attach layer ${layer.id}`);\n    }\n    this._attachedLayers.push(layer);\n};\n\nGeometryLayer.prototype.detach = function detach(layer) {\n    const count = this._attachedLayers.length;\n    this._attachedLayers = this._attachedLayers.filter(attached => attached.id != layer.id);\n    return this._attachedLayers.length < count;\n};\n\n/**\n * Don't use directly constructor to instance a new Layer\n * use addLayer in {@link View}\n * @example\n * // add and create a new Layer\n * const newLayer = view.addLayer({options});\n *\n * // Change layer's visibilty\n * const layerToChange = view.getLayers(layer => layer.id == 'idLayerToChange')[0];\n * layerToChange.visible = false;\n * view.notifyChange(true); // update viewer\n *\n * // Change layer's opacity\n * const layerToChange = view.getLayers(layer => layer.id == 'idLayerToChange')[0];\n * layerToChange.opacity = 0.5;\n * view.notifyChange(true); // update viewer\n *\n * // Listen properties\n * const layerToListen = view.getLayers(layer => layer.id == 'idLayerToListen')[0];\n * layerToListen.addEventListener('visible-property-changed', (event) => console.log(event));\n * layerToListen.addEventListener('opacity-property-changed', (event) => console.log(event));\n * @constructor\n * @protected\n * @param      {String}  id\n */\nfunction Layer(id) {\n    Object.defineProperty(this, 'id', {\n        value: id,\n        writable: false,\n    });\n}\n\nLayer.prototype = Object.create(EventDispatcher.prototype);\nLayer.prototype.constructor = Layer;\n\nconst ImageryLayers = {\n    // move layer to new index\n    // After the modification :\n    //      * the minimum sequence will always be 0\n    //      * the maximum sequence will always be layers.lenght - 1\n    // the ordering of all layers (Except that specified) doesn't change\n    moveLayerToIndex: function moveLayerToIndex(layer, newIndex, imageryLayers) {\n        newIndex = Math.min(newIndex, imageryLayers.length - 1);\n        newIndex = Math.max(newIndex, 0);\n        const oldIndex = layer.sequence;\n\n        for (const imagery of imageryLayers) {\n            if (imagery.id === layer.id) {\n                // change index of specified layer\n                imagery.sequence = newIndex;\n            } else if (imagery.sequence > oldIndex && imagery.sequence <= newIndex) {\n                // down all layers between the old index and new index (to compensate the deletion of the old index)\n                imagery.sequence--;\n            } else if (imagery.sequence >= newIndex && imagery.sequence < oldIndex) {\n                // up all layers between the new index and old index (to compensate the insertion of the new index)\n                imagery.sequence++;\n            }\n        }\n    },\n\n    moveLayerDown: function moveLayerDown(layer, imageryLayers) {\n        if (layer.sequence > 0) {\n            this.moveLayerToIndex(layer, layer.sequence - 1, imageryLayers);\n        }\n    },\n\n    moveLayerUp: function moveLayerUp(layer, imageryLayers) {\n        const m = imageryLayers.length - 1;\n        if (layer.sequence < m) {\n            this.moveLayerToIndex(layer, layer.sequence + 1, imageryLayers);\n        }\n    },\n\n    getColorLayersIdOrderedBySequence: function getColorLayersIdOrderedBySequence(imageryLayers) {\n        const copy = Array.from(imageryLayers);\n        copy.sort((a, b) => a.sequence - b.sequence);\n        return copy.map(l => l.id);\n    },\n};\n\nexport { GeometryLayer, Layer, ImageryLayers };\n"]}