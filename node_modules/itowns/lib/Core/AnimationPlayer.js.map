{"version":3,"sources":["../../src/Core/AnimationPlayer.js"],"names":["THREE","FRAMERATE","FRAME_DURATION","debugAnimation","PLAYER_STATE","STOP","PLAY","END","PAUSE","debugMsg","_DEBUG","resetTimer","player","id","clearInterval","undefined","waitTimer","keyframe","finishAnimation","isEnded","dispatchEvent","type","animation","resolve","promise","setPlayerState","state","AnimationPlayer","setInterval","frame","bind","r","waitingFrame","resolveWait","timew","Math","floor","window","setTimeout","play","then","duration","animate","EventDispatcher","Animation","params","name","AnimatedExpression","root","expression","keyFrame"],"mappings":"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","file":"AnimationPlayer.js","sourcesContent":["import * as THREE from 'three';\n\nconst FRAMERATE = 60;\nconst FRAME_DURATION = 1000 / FRAMERATE;\n// if is true console.log are enabled to sniff animation'state\nconst debugAnimation = false;\n\n// player statut\nconst PLAYER_STATE = {\n    // player is stopped\n    STOP: 0,\n    // player plays animation\n    PLAY: 1,\n    // player is at the end of an animation\n    END: 2,\n    // player is paused\n    PAUSE: 3,\n};\n\nconst debugMsg =\n    [\n        'Stop',\n        'Play',\n        'End',\n        'Pause',\n    ];\n\n// if debugAnimation is true console.log are enabled to sniff animation'state\nlet _DEBUG = null;\n\nif (debugAnimation) {\n    _DEBUG = function DEBUG(message, animation) {\n        if (animation) {\n            // eslint-disable-next-line no-console\n            console.info('Animation ', message, ' : ', animation.name);\n        }\n    };\n} else {\n    _DEBUG = function _DEBUG() {};\n}\n\n// Private functions\n// stop timer and re-init parameter\nconst resetTimer = function resetTimer(player) {\n    if (player.id) {\n        clearInterval(player.id);\n        player.id = undefined;\n    }\n    if (player.waitTimer) {\n        clearInterval(player.waitTimer);\n        player.waitTimer = undefined;\n    }\n    player.keyframe = 0;\n};\n\n// finish animation and re-init parameter\nconst finishAnimation = function finishAnimation(player) {\n    resetTimer(player);\n    if (player.isEnded()) {\n        player.dispatchEvent({\n            type: 'animation-ended',\n            animation: player.animation,\n        });\n    }\n    player.dispatchEvent({\n        type: 'animation-stopped',\n        animation: player.animation,\n    });\n    player.animation = null;\n    if (player.resolve) {\n        player.resolve();\n        player.resolve = null;\n        player.promise = null;\n    }\n};\n\nconst setPlayerState = function setPlayerState(player, state) {\n    player.state = state;\n    _DEBUG(debugMsg[state], player.animation);\n};\n\n/**\n * It can play, pause or stop Animation or AnimationExpression (See below).\n * AnimationPlayer is needed to use Animation or AnimationExpression\n * AnimationPlayer emits events :\n *       - for each animation's frame;\n *       - when Animation is stopped\n *       - when Animation is ending\n */\nclass AnimationPlayer extends THREE.EventDispatcher {\n    constructor() {\n        super();\n        this.id = null;\n        this.keyframe = 0;\n        this.animation = null;\n        this.resolve = null;\n        this.promise = null;\n        this.state = PLAYER_STATE.STOP;\n        this.waitTimer = null;\n    }\n\n    isPlaying() {\n        return this.state === PLAYER_STATE.PLAY;\n    }\n\n    isStopped() {\n        return this.state === PLAYER_STATE.STOP;\n    }\n\n    isEnded() {\n        return this.state === PLAYER_STATE.END;\n    }\n\n    // Public functions\n\n    /**\n     * Play one animation.\n     * If another animation is playing, it's stopped and the new animation is played.\n     *\n     * @param {Animation} animation - The animation to play\n     * @return {Promise<void>} - Promise is resolved when animation is stopped or finished\n     */\n    play(animation) {\n        this.animation = animation;\n        this.dispatchEvent({\n            type: 'animation-started',\n            animation });\n        setPlayerState(this, PLAYER_STATE.PLAY);\n        resetTimer(this);\n        this.id = setInterval(this.frame.bind(this), FRAME_DURATION);\n        this.promise = new Promise((r) => { this.resolve = r; });\n        return this.promise;\n    }\n\n    /**\n     * Play an animation after a number of frames.\n     *\n     * @param      {Animation}  animation    The animation to play\n     * @param      {number}  waitingFrame    The waiting time before start animation (time in frame)\n     * @return     {Promise<void>} Promise is resolved when animation is stopped or finished\n     */\n    playLater(animation, waitingFrame) {\n        this.resolveWait = null;\n        const promise = new Promise((r) => { this.resolveWait = r; });\n        const timew = Math.floor(FRAME_DURATION * waitingFrame);\n        window.clearInterval(this.waitTimer);\n        this.waitTimer = window.setTimeout(() => { this.play(animation).then(() => this.resolveWait()); }, timew);\n        return promise;\n    }\n\n    /**\n     * Stop the current animation.\n     *\n     * @return  {Promise<void>}  Promise is resolved when animation is stopped or finished\n     */\n    stop() {\n        setPlayerState(this, PLAYER_STATE.STOP);\n        finishAnimation(this);\n        // needed to return promise to wait sync\n        return Promise.resolve();\n    }\n\n    /**\n     * Executed for each frame.\n     *\n     * @private\n     */\n    frame() {\n        if (this.keyframe < this.animation.duration) {\n            if (this.animation.animate) {\n                this.animation.animate(this.keyframe);\n            }\n            this.keyframe++;\n            this.dispatchEvent({\n                type: 'animation-frame',\n            });\n        }\n        else {\n            setPlayerState(this, PLAYER_STATE.END);\n            finishAnimation(this);\n        }\n    }\n}\n\n/**\n * Animation is played by the AnimationPlayer during the time of duration\n * During playback, the AnimationPlayer emits events for each frame\n * Animation is used to execute a callback to each frame\n */\nclass Animation {\n    /**\n     * @param {Object}  params\n     * @param {?number} params.duration - The animation's duration in number of frames. {@link FRAMERATE} is number of frames in one seconde.\n     * @param {string}  params.name     - The animation's name. It's used for debug message.\n     */\n    constructor(params) {\n        this.duration = params.duration || FRAMERATE;\n        this.name = params.name;\n    }\n}\n\n/**\n * AnimatedExpression is played by the AnimationPlayer during the time of duration\n * During playback, the AnimationPlayer emits event for each frame and\n * it applies expression on root.\n * AnimatedExpression is used to change object's values for each frame\n */\nclass AnimatedExpression extends Animation {\n    /**\n     * @param {Object}   params\n     * @param {?number}  params.duration   - Duration in number of frames. {@link FRAMERATE} is number of frames in one seconde.\n     * @param {Object}   params.root       - Object in scene to animate\n     * @param {function(Object,number):void} params.expression - Function applied to root for each frame, arguments are the root object and the ratio of completion.\n     * @param {string}   params.name       - The animation's name. It's used for debug message\n     */\n    constructor(params) {\n        super(params);\n        this.root = params.root;\n        this.expression = params.expression;\n    }\n    animate(keyFrame) {\n        this.expression(this.root, keyFrame / (this.duration - 1));\n    }\n}\n\nexport { Animation, AnimatedExpression };\nexport default AnimationPlayer;\n"]}