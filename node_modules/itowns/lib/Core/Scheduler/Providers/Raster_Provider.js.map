{"version":3,"sources":["../../../../src/Core/Scheduler/Providers/Raster_Provider.js"],"names":["THREE","supportedFormats","fetcher","xml","json","getExtension","path","String","basename","split","pop","pos","lastIndexOf","slice","getExtentFromGpxFile","file","bound","getElementsByTagName","west","getAttribute","east","south","north","createTextureFromVector","tile","layer","material","resolve","type","coords","extent","as","projection","result","pitch","Vector4","texture","createTextureFromFeature","feature","style","zoom","level","preprocessDataLayer","url","Error","extention","toLowerCase","format","options","includes","mimetype","reject","then","min","max","noTextureParentOutsideLimit","buildExtent","crsIn","parse","reprojection","geometry","geojson","kml","gpx","stroke","originalprojection","tileInsideLimit","intersectsExtent","executeCommand","command","requester"],"mappings":"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","file":"Raster_Provider.js","sourcesContent":["/**\n * Class: Raster_Provider\n * Description: Provides textures from a vector data\n */\n\n\nimport * as THREE from 'three';\nimport togeojson from 'togeojson';\nimport Extent from '../../Geographic/Extent';\nimport Feature2Texture from '../../../Renderer/ThreeExtended/Feature2Texture';\nimport GeoJSON2Features from '../../../Renderer/ThreeExtended/GeoJSON2Features';\nimport Fetcher from './Fetcher';\n\nconst supportedFormats = [\n    'vector/kml',\n    'vector/gpx',\n    'vector/geojson',\n];\n\nconst fetcher = {\n    'vector/kml': Fetcher.xml,\n    'vector/gpx': Fetcher.xml,\n    'vector/geojson': Fetcher.json,\n};\n\nfunction getExtension(path) {\n    path = String(path);\n    const basename = path.split(/[\\\\/]/).pop();\n    const pos = basename.lastIndexOf('.');\n    if (basename === '' || pos < 1) {\n        return '';\n    }\n    return basename.slice(pos + 1);\n}\n\nfunction getExtentFromGpxFile(file) {\n    const bound = file.getElementsByTagName('bounds')[0];\n    if (bound) {\n        const west = bound.getAttribute('minlon');\n        const east = bound.getAttribute('maxlon');\n        const south = bound.getAttribute('minlat');\n        const north = bound.getAttribute('maxlat');\n        return new Extent('EPSG:4326', west, east, south, north);\n    }\n    return new Extent('EPSG:4326', -180, 180, -90, 90);\n}\n\nfunction createTextureFromVector(tile, layer) {\n    if (!tile.material) {\n        return Promise.resolve();\n    }\n\n    if (layer.type == 'color') {\n        const coords = tile.extent.as(layer.projection);\n        const result = { pitch: new THREE.Vector4(0, 0, 1, 1) };\n        result.texture = Feature2Texture.createTextureFromFeature(layer.feature, tile.extent, 256, layer.style);\n        result.texture.extent = tile.extent;\n        result.texture.coords = coords;\n        result.texture.coords.zoom = tile.level;\n        return Promise.resolve(result);\n    } else {\n        return Promise.resolve();\n    }\n}\n\nexport default {\n    preprocessDataLayer(layer) {\n        if (!layer.url) {\n            throw new Error('layer.url is required');\n        }\n\n        const extention = getExtension(layer.url).toLowerCase();\n        const format = `vector/${extention}`;\n        layer.options = layer.options || {};\n\n        if (!supportedFormats.includes(format) && !layer.options.mimetype) {\n            return Promise.reject(new Error('layer.options.mimetype is required'));\n        } else {\n            return fetcher[format](layer.url).then((file) => {\n                // Know if it's an xml file, then it can be kml or gpx\n                if (file.getElementsByTagName) {\n                    if (file.getElementsByTagName('kml')[0]) {\n                        layer.options.mimetype = 'vector/kml';\n                        // KML crs specification : 'EPSG:4326'\n                        layer.projection = layer.projection || 'EPSG:4326';\n                    } else if (file.getElementsByTagName('gpx')[0]) {\n                        // GPX crs specification : 'EPSG:4326'\n                        layer.options.mimetype = 'vector/gpx';\n                        layer.projection = layer.projection || 'EPSG:4326';\n                    } else {\n                        throw new Error('Unsupported xml file data vector');\n                    }\n                // Know if it's an geojson file\n                } else if (file.type == 'Feature' || file.type == 'FeatureCollection') {\n                    layer.options.mimetype = 'vector/geojson';\n                } else {\n                    throw new Error('Unsupported json file data vector');\n                }\n\n                if (!(layer.extent instanceof Extent)) {\n                    layer.extent = new Extent(layer.projection, layer.extent);\n                }\n\n                if (!layer.options.zoom) {\n                    layer.options.zoom = { min: 5, max: 21 };\n                }\n\n                layer.format = layer.options.mimetype;\n                layer.style = layer.style || {};\n\n                // Rasterization of data vector\n                // It shouldn't use parent's texture outside the extent\n                // Otherwise artefacts appear at the outer edge\n                layer.noTextureParentOutsideLimit = true;\n                const options = { buildExtent: true, crsIn: layer.projection };\n\n                if (layer.options.mimetype === 'vector/geojson') {\n                    layer.feature = GeoJSON2Features.parse(layer.reprojection, file, layer.extent, options);\n                    layer.extent = layer.feature.extent || layer.feature.geometry.extent;\n                } else if (layer.options.mimetype === 'vector/kml') {\n                    const geojson = togeojson.kml(file);\n                    layer.feature = GeoJSON2Features.parse(layer.reprojection, geojson, layer.extent, options);\n                    layer.extent = layer.feature.extent;\n                } else if (layer.options.mimetype === 'vector/gpx') {\n                    const geojson = togeojson.gpx(file);\n                    layer.style.stroke = layer.style.stroke || 'red';\n                    layer.extent = getExtentFromGpxFile(file);\n                    layer.feature = GeoJSON2Features.parse(layer.reprojection, geojson, layer.extent, options);\n                    layer.extent = layer.feature.extent;\n                }\n                // GeoJSON2Features.parse reprojects in local tile texture space\n                // Rasterizer gives textures in this new reprojection space\n                // layer.projection is now reprojection\n                layer.originalprojection = layer.projection;\n                layer.projection = layer.reprojection;\n            });\n        }\n    },\n    tileInsideLimit(tile, layer) {\n        return tile.level >= layer.options.zoom.min && tile.level <= layer.options.zoom.max && layer.extent.intersectsExtent(tile.extent);\n    },\n    executeCommand(command) {\n        const layer = command.layer;\n        if (!supportedFormats.includes(layer.format)) {\n            return Promise.reject(new Error(`Unsupported mimetype ${layer.format}`));\n        }\n        const tile = command.requester;\n\n        return createTextureFromVector(tile, layer);\n    },\n};\n"]}