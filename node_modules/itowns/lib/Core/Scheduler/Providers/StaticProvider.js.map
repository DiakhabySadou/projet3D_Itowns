{"version":3,"sources":["../../../../src/Core/Scheduler/Providers/StaticProvider.js"],"names":["selectBestImageForExtent","images","extent","selection","entry","isInside","d","dimensions","e","x","y","getTexture","tile","layer","tileInsideLimit","reject","material","resolve","Error","url","href","substr","lastIndexOf","image","fn","mimetype","startsWith","getColorTextureByUrl","getXBilTextureByUrl","networkOptions","then","texture","result","pitch","coords","zoom","level","file","offsetToParent","preprocessDataLayer","projection","options","canTileTextureBeImproved","URL","window","location","json","metadata","push","id","layerUpdateState","s","mat","layerType","type","currentTexture","getLayerTextures","executeCommand","command","requester"],"mappings":"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","file":"StaticProvider.js","sourcesContent":["import { Vector4 } from 'three';\nimport Extent from '../../Geographic/Extent';\nimport OGCWebServiceHelper from './OGCWebServiceHelper';\nimport Fetcher from './Fetcher';\nimport { l_COLOR, l_ELEVATION } from '../../../Renderer/LayeredMaterialConstants';\n\n// select the smallest image entirely covering the tile\nfunction selectBestImageForExtent(images, extent) {\n    let selection;\n    for (const entry of images) {\n        if (extent.isInside(entry.extent)) {\n            if (!selection) {\n                selection = entry;\n            } else {\n                const d = selection.extent.dimensions();\n                const e = entry.extent.dimensions();\n                if (e.x <= d.x && e.y <= d.y) {\n                    selection = entry;\n                }\n            }\n        }\n    }\n    return selection;\n}\n\nfunction getTexture(tile, layer) {\n    if (!layer.tileInsideLimit(tile, layer)) {\n        return Promise.reject(`Tile '${tile}' is outside layer bbox ${layer.extent}`);\n    }\n    if (!tile.material) {\n        return Promise.resolve();\n    }\n\n    if (!layer.images) {\n        return Promise.reject();\n    }\n\n    const selection = selectBestImageForExtent(layer.images, tile.extent);\n\n    if (!selection) {\n        return Promise.reject(\n            new Error(`No available image for tile ${tile}`));\n    }\n\n    const url = layer.url.href.substr(0, layer.url.href.lastIndexOf('/') + 1) + selection.image;\n    const fn = layer.mimetype.startsWith('image') ? OGCWebServiceHelper.getColorTextureByUrl : OGCWebServiceHelper.getXBilTextureByUrl;\n    return fn(url, layer.networkOptions).then((texture) => {\n        // adjust pitch\n        const result = {\n            texture,\n            pitch: new Vector4(0, 0, 1, 1),\n        };\n\n        result.texture.extent = selection.extent;\n        result.texture.coords = selection.extent;\n        if (!result.texture.coords.zoom || result.texture.coords.zoom > tile.level) {\n            result.texture.coords.zoom = tile.level;\n            result.texture.file = selection.image;\n        }\n        // TODO: modify TileFS to handle tiles with ratio != image's ratio\n        result.pitch = tile.extent.offsetToParent(selection.extent);\n\n\n        return result;\n    });\n}\n\n\n/**\n * This provider uses no protocol but instead download static images directly.\n *\n * It uses as input 'image_filename: extent' values and then tries to find the best image\n * for a given tile using the extent property.\n */\nexport default {\n    preprocessDataLayer(layer) {\n        if (!layer.extent) {\n            throw new Error('layer.extent is required');\n        }\n\n        if (!(layer.extent instanceof Extent)) {\n            layer.extent = new Extent(layer.projection, ...layer.extent);\n        }\n\n        layer.options = {};\n        layer.canTileTextureBeImproved = layer.canTileTextureBeImproved || this.canTileTextureBeImproved;\n        layer.url = new URL(layer.url, window.location);\n        return Fetcher.json(layer.url.href, layer.networkOptions).then((metadata) => {\n            layer.images = [];\n            // eslint-disable-next-line guard-for-in\n            for (const image in metadata) {\n                const extent = new Extent(layer.projection, ...metadata[image]);\n                layer.images.push({\n                    image,\n                    extent,\n                });\n            }\n        });\n    },\n\n    tileInsideLimit(tile, layer) {\n        if (!layer.images) {\n            return false;\n        }\n        // images search is quite costly so let's try to take a shortcut\n        if (layer.id in tile.layerUpdateState) {\n            return true;\n        }\n\n        for (const entry of layer.images) {\n            if (tile.extent.isInside(entry.extent)) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    canTileTextureBeImproved(layer, tile) {\n        if (!layer.images) {\n            return false;\n        }\n        const s = selectBestImageForExtent(layer.images, tile.extent);\n        if (!s) {\n            return false;\n        }\n        const mat = tile.material;\n        const layerType = layer.type === 'color' ? l_COLOR : l_ELEVATION;\n        const currentTexture = mat.getLayerTextures(layerType, layer.id)[0];\n        if (!currentTexture.file) {\n            return true;\n        }\n        return currentTexture.file != s.image;\n    },\n\n    executeCommand(command) {\n        const tile = command.requester;\n        const layer = command.layer;\n        return getTexture(tile, layer);\n    },\n};\n"]}