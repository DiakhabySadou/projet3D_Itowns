{"version":3,"sources":["../../../../src/Core/Scheduler/Providers/WMS_Provider.js"],"names":["THREE","mimeTypeByTagName","JPEG","PNG","GIF","PPM","TIFF","GeoTIFF","WebCGM","SVG","WMS_XML","WBMP","MIME","_parseSupportedCrs","version","xmlLayer","supportedCrs","crsPropName","children","childElem","tagName","concat","textContent","trim","split","parentNode","parseLayerBoundingBox","targetCrs","getAttribute","parseGeoBounds","geoTagName","WMS_Provider","prototype","parseSupportedCrs","parseSupportedFormats","xmlCapa","Array","map","call","querySelectorAll","elm","parseExtent","extent","url","bbox","layer","box","as","projection","w","west","s","south","e","east","n","north","bboxInUnit","axisOrder","customUrl","replace","tileTextureCount","tile","crs","tileMatrixSet","options","computeTileMatrixSetCoordinates","getCoordsForLayer","length","preprocessDataLayer","name","Error","zoom","min","max","width","heightMapWidth","style","transparent","getCapPromise","disableGetCap","resolve","format","xml","networkOptions","then","checkCapabilities","layers","getCapLayer","l","querySelector","innerHTML","has","size","values","next","value","isInside","supportedFormats","includes","tileInsideLimit","level","intersectsExtent","getColorTexture","targetLevel","tileCoords","reject","material","undefined","parentAtLevel","parent","coords","pitch","Vector4","offsetToParent","result","getColorTextureByUrl","texture","executeCommand","command","requester","getTextureFunction","getColorTextures","bind","func","promises","coord","push","all"],"mappings":"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","file":"WMS_Provider.js","sourcesContent":["/**\n * Generated On: 2015-10-5\n * Class: WMS_Provider\n * Description: Provides data from a WMS stream\n */\n\nimport * as THREE from 'three';\nimport Extent from '../../Geographic/Extent';\nimport OGCWebServiceHelper from './OGCWebServiceHelper';\nimport Fetcher from './Fetcher';\n\nconst mimeTypeByTagName = {\n    JPEG: 'image/jpeg',\n    PNG: 'image/png',\n    GIF: 'image/gif',\n    PPM: 'image/x‑portable‑pixmap',\n    TIFF: 'image/tiff',\n    GeoTIFF: 'image/tiff',\n    WebCGM: 'image/cgm;Version=4;ProfileId=WebCGM',\n    SVG: 'image/svg+xml',\n    WMS_XML: 'application/vnd.ogc.wms_xml',\n    'GML.1': 'application/gml+xml',\n    'GML.2': 'application/gml+xml',\n    'GML.3': 'application/gml+xml',\n    WBMP: 'image/vnd.wap.wbmp',\n    MIME: 'www/mime', // Not sure of this one (there's also message/rfc822)\n};\n/* For reference, there are also these 2 possible tags that do not translate to mimetype\n   INIMAGE display text in the returned image -->\n   BLANK return an image with all pixels transparent if\n   */\n\nfunction _parseSupportedCrs(version, xmlLayer) {\n    let supportedCrs = [];\n    const crsPropName = version === '1.3.0' ? 'CRS' : 'SRS';\n\n    for (const childElem of xmlLayer.children) {\n        if (childElem.tagName === crsPropName) {\n            supportedCrs = supportedCrs.concat(childElem.textContent.trim().split(' '));\n        }\n    }\n    if (xmlLayer.parentNode && xmlLayer.parentNode.tagName === 'Layer') {\n        supportedCrs = supportedCrs.concat(_parseSupportedCrs(version, xmlLayer.parentNode));\n    }\n\n    return supportedCrs;\n}\n\nfunction parseLayerBoundingBox(version, targetCrs, xmlLayer) {\n    const crsPropName = version === '1.3.0' ? 'CRS' : 'SRS';\n    for (const childElem of xmlLayer.children) {\n        if (childElem.tagName === 'BoundingBox' && (!targetCrs || targetCrs === childElem.getAttribute(crsPropName))) {\n            return new Extent(\n                    childElem.getAttribute(crsPropName),\n                    childElem.getAttribute('minx'),\n                    childElem.getAttribute('maxx'),\n                    childElem.getAttribute('miny'),\n                    childElem.getAttribute('maxy'));\n        }\n    }\n    if (xmlLayer.parentNode && xmlLayer.parentNode.tagName === 'Layer') {\n        return parseLayerBoundingBox(version, targetCrs, xmlLayer.parentNode);\n    }\n}\n\nfunction parseGeoBounds(version, xmlLayer) {\n    const geoTagName = version === '1.3.0' ? 'EX_GeographicBoundingBox' : 'LatLonBoundingBox';\n    for (const childElem of xmlLayer.children) {\n        if (childElem.tagName === geoTagName) {\n            return new Extent(\n                    'CRS:84',\n                    childElem.getAttribute('minx'),\n                    childElem.getAttribute('maxx'),\n                    childElem.getAttribute('miny'),\n                    childElem.getAttribute('maxy'));\n        }\n    }\n    if (xmlLayer.parentNode && xmlLayer.parentNode.tagName === 'Layer') {\n        return parseGeoBounds(version, xmlLayer.parentNode);\n    }\n}\n\n/**\n * Return url wmts MNT\n * @param {String} options.url: service base url\n * @param {String} options.layer: requested data layer\n * @param {String} options.format: image format (default: format/jpeg)\n */\nfunction WMS_Provider() {\n}\n\nWMS_Provider.prototype.parseSupportedCrs = function parseSupportedCrs(version, xmlLayer) {\n    return new Set(_parseSupportedCrs(version, xmlLayer));\n};\n\nWMS_Provider.prototype.parseSupportedFormats = function parseSupportedFormats(version, xmlCapa) {\n    if (version === '1.0.0') {\n        return Array.prototype.map.call(\n                xmlCapa.querySelectorAll('Capability > Request > Map > Format > *'),\n                elm => mimeTypeByTagName[elm.tagName]);\n    } else {\n        return Array.prototype.map.call(\n            xmlCapa.querySelectorAll('Capability > Request > GetMap > Format'),\n            elm => elm.textContent.trim());\n    }\n};\n\nWMS_Provider.prototype.parseExtent = function parseExtent(version, targetCrs, xmlLayer) {\n    let extent = parseLayerBoundingBox(version, targetCrs, xmlLayer);\n    if (extent) {\n        return extent;\n    }\n\n    // fallback to CRS:84 boundingbox\n    extent = parseLayerBoundingBox(version, 'CRS:84', xmlLayer);\n    if (extent) {\n        return extent;\n    }\n\n    // fallback to any other BoundingBox\n    extent = parseLayerBoundingBox(version, null, xmlLayer);\n    if (extent) {\n        return extent;\n    }\n\n    // fallback to imprecise geographic bounds\n    return parseGeoBounds(version, xmlLayer);\n};\n\nWMS_Provider.prototype.url = function url(bbox, layer) {\n    const box = bbox.as(layer.projection);\n    const w = box.west();\n    const s = box.south();\n    const e = box.east();\n    const n = box.north();\n\n    const bboxInUnit = layer.axisOrder === 'swne' ?\n        `${s},${w},${n},${e}` :\n        `${w},${s},${e},${n}`;\n\n    return layer.customUrl.replace('%bbox', bboxInUnit);\n};\n\nWMS_Provider.prototype.tileTextureCount = function tileTextureCount(tile, layer) {\n    if (tile.extent.crs() == layer.projection) {\n        return 1;\n    } else {\n        const tileMatrixSet = layer.options.tileMatrixSet;\n        OGCWebServiceHelper.computeTileMatrixSetCoordinates(tile, tileMatrixSet);\n        return tile.getCoordsForLayer(layer).length;\n    }\n};\n\nWMS_Provider.prototype.preprocessDataLayer = function preprocessDataLayer(layer) {\n    if (!layer.name) {\n        throw new Error('layer.name is required.');\n    }\n    layer.options = layer.options || {};\n    if (!layer.options.zoom) {\n        layer.options.zoom = { min: 0, max: 21 };\n    }\n    layer.width = layer.heightMapWidth || 256;\n    layer.version = layer.version || '1.3.0';\n    layer.style = layer.style || '';\n    layer.transparent = layer.transparent || false;\n\n    let crsPropName = 'SRS';\n    if (layer.version === '1.3.0') {\n        crsPropName = 'CRS';\n    }\n\n    if (layer.extent && !(layer.extent instanceof Extent) && layer.projection) {\n        layer.extent = new Extent(layer.projection, layer.extent);\n    }\n\n    let getCapPromise;\n    if (layer.disableGetCap) {\n        getCapPromise = Promise.resolve();\n        if (!layer.projection) {\n            throw new Error('layer.projection is required');\n        }\n        if (!layer.extent) {\n            throw new Error('layer.extent is required');\n        }\n        // TODO change layer.options.mimetype\n        layer.format = layer.format || 'image/png';\n    } else {\n        getCapPromise = Fetcher.xml(`${layer.url}?service=WMS&version=${layer.version}&request=GetCapabilities`, layer.networkOptions)\n            .then(xml => this.checkCapabilities(layer, xml));\n    }\n\n    return getCapPromise.then(() => {\n        if (!layer.axisOrder) {\n            // 4326 (lat/long) axis order depends on the WMS version used\n            if (layer.projection == 'EPSG:4326') {\n                // EPSG 4326 x = lat, long = y\n                // version 1.1.0 long/lat while version 1.3.0 mandates xy (so lat,long)\n                layer.axisOrder = (layer.version === '1.1.0' ? 'wsen' : 'swne');\n            } else {\n                // xy,xy order\n                layer.axisOrder = 'wsen';\n            }\n        }\n\n        layer.customUrl = `${layer.url\n        }?SERVICE=WMS&REQUEST=GetMap&LAYERS=${layer.name\n        }&VERSION=${layer.version\n        }&STYLES=${layer.style\n        }&FORMAT=${layer.format\n        }&TRANSPARENT=${layer.transparent\n        }&BBOX=%bbox` +\n        `&${crsPropName}=${layer.projection\n        }&WIDTH=${layer.width\n        }&HEIGHT=${layer.width}`;\n    });\n};\n\nWMS_Provider.prototype.checkCapabilities = function getAndCheckCapabilities(layer, xmlCapa) {\n    const layers = xmlCapa.querySelectorAll('Layer');\n    let getCapLayer;\n    for (const l of layers) {\n        const name = l.querySelector('Name').innerHTML.trim();\n        if (name === layer.name) {\n            getCapLayer = l;\n            break;\n        }\n    }\n    if (!getCapLayer) {\n        throw new Error(`Cannot find layer ${layer.name} in capabilities`);\n    }\n\n    // get CRS list\n    const supportedCrs = this.parseSupportedCrs(layer.version, getCapLayer);\n\n    if (layer.projection) {\n        if (!supportedCrs.has(layer.projection)) {\n            throw new Error(`Layer ${layer.name} does not support projection ${layer.projection}`);\n        }\n    } else if (supportedCrs.size !== 1) {\n        throw new Error(`Cannot infer projection from capabilities for ${layer.name}`);\n    } else {\n        layer.projection = supportedCrs.values().next().value;\n    }\n\n    // check extent\n    const extent = this.parseExtent(layer.version, layer.projection, getCapLayer);\n    if (layer.extent && !layer.extent.isInside(extent)) {\n        // TODO we could automagically make the intersection and just check if it's not empty?\n        throw new Error(`Extent from capabilities does not contain layer.extent for ${layer.name}`);\n    } else if (!layer.extent) {\n        layer.extent = extent.as(layer.projection);\n    }\n\n    // check format\n    const supportedFormats = this.parseSupportedFormats(layer.version, xmlCapa);\n    if (layer.format && !supportedFormats.includes(layer.format)) {\n        throw new Error(`Declared layer.format ${layer.format} is not supported by the wms server for ${layer.name}`);\n    } else if (!layer.format) {\n        if (supportedFormats.length === 1) {\n            layer.format = supportedFormats[0];\n        } else {\n            throw new Error('Please specify a format in layer.format');\n        }\n    }\n};\n\nWMS_Provider.prototype.tileInsideLimit = function tileInsideLimit(tile, layer) {\n    return tile.level >= layer.options.zoom.min &&\n        tile.level <= layer.options.zoom.max &&\n        layer.extent.intersectsExtent(tile.extent);\n};\n\nWMS_Provider.prototype.getColorTexture = function getColorTexture(tile, layer, targetLevel, tileCoords) {\n    if (!this.tileInsideLimit(tile, layer)) {\n        return Promise.reject(`Tile '${tile}' is outside layer bbox ${layer.extent}`);\n    }\n    if (tile.material === null) {\n        return Promise.resolve();\n    }\n\n    let extent = tileCoords ? tileCoords.as(layer.projection) : tile.extent;\n    // if no specific level requester, use tile.level\n    if (targetLevel === undefined) {\n        targetLevel = tile.level;\n    } else if (!tileCoords) {\n        let parentAtLevel = tile;\n        while (parentAtLevel && parentAtLevel.level > targetLevel) {\n            parentAtLevel = parentAtLevel.parent;\n        }\n        if (!parentAtLevel) {\n            return Promise.reject(`Invalid targetLevel requested ${targetLevel}`);\n        }\n        extent = parentAtLevel.extent;\n        targetLevel = parentAtLevel.level;\n    }\n\n    const coords = extent.as(layer.projection);\n    const url = this.url(coords, layer);\n    const pitch = tileCoords ? new THREE.Vector4(0, 0, 1, 1) : tile.extent.offsetToParent(extent);\n    const result = { pitch };\n\n    return OGCWebServiceHelper.getColorTextureByUrl(url, layer.networkOptions).then((texture) => {\n        result.texture = texture;\n        result.texture.extent = extent;\n        if (tileCoords) {\n            result.texture.coords = tileCoords;\n        } else {\n            result.texture.coords = coords;\n            // LayeredMaterial expects coords.zoom to exist, and describe the\n            // precision of the texture (a la WMTS).\n            result.texture.coords.zoom = targetLevel;\n        }\n        return result;\n    });\n};\n\nWMS_Provider.prototype.executeCommand = function executeCommand(command) {\n    const tile = command.requester;\n\n    const layer = command.layer;\n    const getTextureFunction = tile.extent.crs() == layer.projection ? this.getColorTexture : this.getColorTextures;\n    const supportedFormats = {\n        'image/png': getTextureFunction.bind(this),\n        'image/jpg': getTextureFunction.bind(this),\n        'image/jpeg': getTextureFunction.bind(this),\n    };\n\n    const func = supportedFormats[layer.format];\n\n    if (func) {\n        return func(tile, layer, command.targetLevel);\n    } else {\n        return Promise.reject(new Error(`Unsupported mimetype ${layer.format}`));\n    }\n};\n\n// In the case where the tilematrixset of the tile don't correspond to the projection of the layer\n// when the projection of the layer corresponds to a tilematrixset inside the tile, like the PM\nWMS_Provider.prototype.getColorTextures = function getColorTextures(tile, layer, targetLevel) {\n    if (tile.material === null) {\n        return Promise.resolve();\n    }\n    const promises = [];\n    for (const coord of tile.getCoordsForLayer(layer)) {\n        promises.push(this.getColorTexture(tile, layer, targetLevel, coord));\n    }\n\n    return Promise.all(promises);\n};\n\nexport default WMS_Provider;\n"]}