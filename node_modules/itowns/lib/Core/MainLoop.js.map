{"version":3,"sources":["../../src/Core/MainLoop.js"],"names":["RENDERING_PAUSED","RENDERING_SCHEDULED","MainLoop","scheduler","engine","renderingState","needsRedraw","gfxEngine","_updateLoopRestarted","prototype","constructor","scheduleViewUpdate","view","forceRedraw","requestAnimationFrame","timestamp","_step","updateElements","context","geometryLayer","elements","element","newElementsToUpdate","update","_attachedLayers","attachedLayer","ready","_update","updateSources","dt","camera","_frameRequesters","length","frameRequester","getLayers","x","y","visible","elementsToUpdate","preUpdate","postUpdate","willRedraw","_lastTimestamp","_changeSources","clear","dim","getWindowSize","oldAutoUpdate","camera3D","matrixAutoUpdate","commandsWaitingExecutionCount","dispatchEvent","type","_renderView","preRender","render","renderView","onAfterRender"],"mappings":"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","file":"MainLoop.js","sourcesContent":["import { EventDispatcher } from 'three';\n\nexport const RENDERING_PAUSED = 0;\nexport const RENDERING_SCHEDULED = 1;\n\nfunction MainLoop(scheduler, engine) {\n    this.renderingState = RENDERING_PAUSED;\n    this.needsRedraw = false;\n    this.scheduler = scheduler;\n    this.gfxEngine = engine; // TODO: remove me\n    this._updateLoopRestarted = true;\n}\n\nMainLoop.prototype = Object.create(EventDispatcher.prototype);\nMainLoop.prototype.constructor = MainLoop;\n\nMainLoop.prototype.scheduleViewUpdate = function scheduleViewUpdate(view, forceRedraw) {\n    this.needsRedraw |= forceRedraw;\n\n    if (this.renderingState !== RENDERING_SCHEDULED) {\n        this.renderingState = RENDERING_SCHEDULED;\n\n        if (__DEBUG__) {\n            document.title += ' âŒ›';\n        }\n\n        requestAnimationFrame((timestamp) => { this._step(view, timestamp); });\n    }\n};\n\nfunction updateElements(context, geometryLayer, elements) {\n    if (!elements) {\n        return;\n    }\n    for (const element of elements) {\n        // update element\n        // TODO find a way to notify attachedLayers when geometryLayer deletes some elements\n        // and then update Debug.js:addGeometryLayerDebugFeatures\n        const newElementsToUpdate = geometryLayer.update(context, geometryLayer, element);\n\n        // update attached layers\n        for (const attachedLayer of geometryLayer._attachedLayers) {\n            if (attachedLayer.ready) {\n                attachedLayer.update(context, attachedLayer, element);\n            }\n        }\n        updateElements(context, geometryLayer, newElementsToUpdate);\n    }\n}\n\nMainLoop.prototype._update = function _update(view, updateSources, dt) {\n    const context = {\n        camera: view.camera,\n        engine: this.gfxEngine,\n        scheduler: this.scheduler,\n        view,\n    };\n\n    // notify the frameRequesters\n    // Frame requesters should keep calling view.notifyChange in their update\n    // function if they want requestAnimationFrame to go on.\n    if (view._frameRequesters.length > 0) {\n        for (const frameRequester of view._frameRequesters) {\n            if (frameRequester.update) {\n                frameRequester.update(dt, this._updateLoopRestarted);\n            }\n        }\n    }\n\n    for (const geometryLayer of view.getLayers((x, y) => !y)) {\n        context.geometryLayer = geometryLayer;\n        if (geometryLayer.ready && geometryLayer.visible) {\n            // `preUpdate` returns an array of elements to update\n            const elementsToUpdate = geometryLayer.preUpdate(context, geometryLayer, updateSources);\n            // `update` is called in `updateElements`.\n            updateElements(context, geometryLayer, elementsToUpdate);\n            // `postUpdate` is called when this geom layer update process is finished\n            geometryLayer.postUpdate(context, geometryLayer, updateSources);\n        }\n    }\n};\n\nMainLoop.prototype._step = function _step(view, timestamp) {\n    const willRedraw = this.needsRedraw;\n    const dt = timestamp - this._lastTimestamp;\n    this._lastTimestamp = timestamp;\n\n    // Reset internal state before calling _update (so future calls to View.notifyChange()\n    // can properly change it)\n    this.needsRedraw = false;\n    this.renderingState = RENDERING_PAUSED;\n    const updateSources = new Set(view._changeSources);\n    view._changeSources.clear();\n\n    // update camera\n    const dim = this.gfxEngine.getWindowSize();\n\n    view.camera.update(dim.x, dim.y);\n\n    // Disable camera's matrix auto update to make sure the camera's\n    // world matrix is never updated mid-update.\n    // Otherwise inconsistencies can appear because object visibility\n    // testing and object drawing could be performed using different\n    // camera matrixWorld.\n    // Note: this is required at least because WEBGLRenderer calls\n    // camera.updateMatrixWorld()\n    const oldAutoUpdate = view.camera.camera3D.matrixAutoUpdate;\n    view.camera.camera3D.matrixAutoUpdate = false;\n\n    // update data-structure\n    this._update(view, updateSources, dt);\n\n    if (this.scheduler.commandsWaitingExecutionCount() == 0) {\n        this.dispatchEvent({ type: 'command-queue-empty' });\n    }\n\n    // Redraw *only* if needed.\n    // (redraws only happen when this.needsRedraw is true, which in turn only happens when\n    // view.notifyChange() is called with redraw=true)\n    // As such there's no continuous update-loop, instead we use a ad-hoc update/render\n    // mechanism.\n    if (willRedraw) {\n        this._renderView(view);\n    }\n\n    // next time, we'll consider that we've just started the loop if we are still PAUSED now\n    this._updateLoopRestarted = this.renderingState === RENDERING_PAUSED;\n\n    if (__DEBUG__) {\n        document.title = document.title.substr(0, document.title.length - 2);\n    }\n\n    view.camera.camera3D.matrixAutoUpdate = oldAutoUpdate;\n};\n\nMainLoop.prototype._renderView = function _renderView(view) {\n    if (view.preRender) {\n        view.preRender();\n    }\n\n    if (view.render) {\n        view.render();\n    } else {\n        // use default rendering method\n        this.gfxEngine.renderView(view);\n    }\n\n    // Mimic three Object3D.onAfterRender (which sadly doesn't work on Scene)\n    view.onAfterRender();\n};\n\nexport default MainLoop;\n"]}