{"version":3,"sources":["../../src/utils/DEMUtils.js"],"names":["THREE","FAST_READ_Z","PRECISE_READ_Z","getElevationValueAt","layer","coord","method","tileHint","result","_readZ","level0Nodes","z","_values","texture","tile","placeObjectOnGround","objectCRS","obj","options","tiles","concat","modifyGeometry","cache","length","matrices","worldFromLocal","parent","matrixWorld","undefined","localFromWorld","Matrix4","getInverse","_updateVector3","position","offset","updateMatrix","updateMatrixWorld","geometry","vertices","success","i","cached","verticesNeedUpdate","BufferGeometry","attributes","count","tmp","Vector3","fromBufferAttribute","prev","needsUpdate","setXYZ","x","y","tileAt","pt","extent","isPointInside","children","t","getLayerTextures","coords","zoom","_canvas","_readTextureValueAt","uv","Math","clamp","image","width","height","data","push","document","createElement","minx","Infinity","miny","maxx","maxy","min","max","dw","dh","ctx","getContext","drawImage","d","getImageData","ox","oy","lerp","materialOptions","colorTextureElevationMinZ","colorTextureElevationMaxZ","_convertUVtoTextureCoords","u","v","up","vp","u1","floor","u2","ceil","v1","v2","wu","wv","_readTextureValueNearestFiltering","vertexU","vertexV","_readTextureValueWithBilinearFiltering","z11","z21","z12","z22","zu1","zu2","_readZFast","_readZCorrect","tileDimensions","tileOwnerDimensions","modulo","lu","lv","tri","Triangle","bary","barycoordFromPoint","z1","a","z2","b","z3","c","temp","coord1","coord2","Vector2","nodes","as","crs","tileWithValidElevationTexture","material","src","id","version","stepsUpInHierarchy","round","offsetScale","offsetInExtent","dimensions","vecCRS","vec","set","copy","applyMatrix4","xyz"],"mappings":"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","file":"DEMUtils.js","sourcesContent":["import * as THREE from 'three';\nimport Coordinates from '../Core/Geographic/Coordinates';\nimport { l_ELEVATION } from '../Renderer/LayeredMaterialConstants';\n\nconst FAST_READ_Z = 0;\nconst PRECISE_READ_Z = 1;\n\n/**\n * Utility module to retrieve elevation at a given coordinates.\n * The returned value is read in the elevation textures used by the graphics card\n * to render the tiles (globe or plane).\n * This implies that the return value may change depending on the current tile resolution.\n */\nexport default {\n    /**\n     * Return current displayed elevation at coord in meters.\n     * @param {GeometryLayer} layer The tile layer owning the elevation textures we're going to query.\n     * This is typically the globeLayer or a planeLayer.\n     * @param {Coordinates} coord The coordinates that we're interested in\n     * @param {Number} method 2 available method: FAST_READ_Z (default) or PRECISE_READ_Z. Chosing between\n     * the 2 is a compromise between performance and visual quality\n     * @param {Array} tileHint Optional array of tiles to speed up the process. You can give candidates tiles\n     * likely to contain 'coord'. Otherwise the lookup process starts from the root.\n     * @return {object}  undefined if no result or z: displayed elevation in meters, texture: where the z value comes from, tile: owner of the texture\n     */\n    getElevationValueAt(layer, coord, method = FAST_READ_Z, tileHint) {\n        const result = _readZ(layer, method, coord, tileHint || layer.level0Nodes);\n        if (result) {\n            return { z: result.coord._values[2], texture: result.texture, tile: result.tile };\n        }\n    },\n\n    /**\n     * Helper method that will position an object directly on the ground.\n     * @param {GeometryLayer} layer The tile layer owning the elevation textures we're going to query.\n     * This is typically the globeLayer or a planeLayer.\n     * @param {string} objectCRS the CRS used by the object coordinates. You probably want to use view.referenceCRS here.\n     * @param {Object3D} obj the object we want to modify.\n     * @param {object} options\n     * @param {number} options.method see getElevationValueAt documentation\n     * @param {boolean} options.modifyGeometry if unset/false, this function will modify object.position. If true, it will\n     * modify obj.geometry.vertices or obj.geometry.attributes.position\n     * @param {Array} tileHint see getElevationValueAt documentation\n     * @return {boolean} true if successful, false if we couldn't lookup the elevation at the given coords\n     */\n    placeObjectOnGround(layer, objectCRS, obj, options = {}, tileHint) {\n        let tiles;\n        if (tileHint) {\n            tiles = tileHint.concat(layer.level0Nodes);\n        } else {\n            tiles = layer.level0Nodes;\n        }\n\n        if (!options.modifyGeometry) {\n            if (options.cache) {\n                options.cache.length = 1;\n            }\n            const matrices = {\n                worldFromLocal: obj.parent ? obj.parent.matrixWorld : undefined,\n                localFromWorld: obj.parent ? new THREE.Matrix4().getInverse(obj.parent.matrixWorld) : undefined,\n            };\n            const result = _updateVector3(\n                layer,\n                options.method || FAST_READ_Z,\n                tiles,\n                objectCRS,\n                obj.position,\n                options.offset || 0,\n                matrices,\n                undefined,\n                options.cache ? options.cache[0] : undefined);\n\n            if (result) {\n                if (options.cache) {\n                    options.cache[0] = result;\n                }\n                obj.updateMatrix();\n                obj.updateMatrixWorld();\n                return true;\n            }\n        } else {\n            const matrices = {\n                worldFromLocal: obj.matrixWorld,\n                localFromWorld: new THREE.Matrix4().getInverse(obj.matrixWorld),\n            };\n\n            const geometry = obj.geometry;\n            if (geometry.vertices) {\n                if (options.cache) {\n                    options.cache.length = geometry.vertices.length;\n                }\n\n                let success = true;\n                const coord = new Coordinates(objectCRS);\n                for (let i = 0; i < geometry.vertices.length; i++) {\n                    const cached = options.cache ? options.cache[i] : undefined;\n\n                    const result = _updateVector3(\n                        layer,\n                        options.method || FAST_READ_Z,\n                        tiles,\n                        objectCRS,\n                        geometry.vertices[i],\n                        options.offset || 0,\n                        matrices,\n                        coord,\n                        cached);\n\n                    if (options.cache) {\n                        options.cache[i] = result;\n                    }\n                    if (!result) {\n                        success = false;\n                    }\n                }\n                geometry.verticesNeedUpdate = true;\n                return success;\n            } else if (geometry instanceof THREE.BufferGeometry) {\n                if (options.cache) {\n                    options.cache.length = geometry.attributes.position.count;\n                }\n                let success = true;\n\n                const tmp = new THREE.Vector3();\n                const coord = new Coordinates(objectCRS);\n                for (let i = 0; i < geometry.attributes.position.count; i++) {\n                    const cached = options.cache ? options.cache[i] : undefined;\n\n                    tmp.fromBufferAttribute(geometry.attributes.position, i);\n                    const prev = tmp.z;\n                    const result = _updateVector3(\n                        layer,\n                        options.method || FAST_READ_Z,\n                        tiles,\n                        objectCRS,\n                        tmp,\n                        options.offset || 0,\n                        matrices,\n                        coord,\n                        cached);\n                    if (options.cache) {\n                        options.cache[i] = result;\n                    }\n                    if (!result) {\n                        success = false;\n                    }\n                    if (prev != tmp.z) {\n                        geometry.attributes.position.needsUpdate = true;\n                    }\n                    geometry.attributes.position.setXYZ(i, tmp.x, tmp.y, tmp.z);\n                }\n                return success;\n            }\n        }\n    },\n    FAST_READ_Z,\n    PRECISE_READ_Z,\n};\n\nfunction tileAt(pt, tile) {\n    if (tile.extent) {\n        if (!tile.extent.isPointInside(pt)) {\n            return undefined;\n        }\n\n        for (let i = 0; i < tile.children.length; i++) {\n            const t = tileAt(pt, tile.children[i]);\n            if (t) {\n                return t;\n            }\n        }\n        if (tile.getLayerTextures(l_ELEVATION)[0].coords.zoom > -1) {\n            return tile;\n        }\n        return undefined;\n    }\n}\n\nlet _canvas;\nfunction _readTextureValueAt(layer, texture, ...uv) {\n    for (let i = 0; i < uv.length; i += 2) {\n        uv[i] = THREE.Math.clamp(uv[i], 0, texture.image.width - 1);\n        uv[i + 1] = THREE.Math.clamp(uv[i + 1], 0, texture.image.height - 1);\n    }\n\n    if (texture.image.data) {\n        // read a single value\n        if (uv.length === 2) {\n            return texture.image.data[uv[1] * texture.image.width + uv[0]];\n        }\n        // or read multiple values\n        const result = [];\n        for (let i = 0; i < uv.length; i += 2) {\n            result.push(texture.image.data[uv[i + 1] * texture.image.width + uv[i]]);\n        }\n        return result;\n    } else {\n        if (!_canvas) {\n            _canvas = document.createElement('canvas');\n            _canvas.width = 2;\n            _canvas.height = 2;\n        }\n        let minx = Infinity;\n        let miny = Infinity;\n        let maxx = -Infinity;\n        let maxy = -Infinity;\n        for (let i = 0; i < uv.length; i += 2) {\n            minx = Math.min(uv[i], minx);\n            miny = Math.min(uv[i + 1], miny);\n            maxx = Math.max(uv[i], maxx);\n            maxy = Math.max(uv[i + 1], maxy);\n        }\n        const dw = maxx - minx + 1;\n        const dh = maxy - miny + 1;\n        _canvas.width = Math.max(_canvas.width, dw);\n        _canvas.height = Math.max(_canvas.height, dh);\n\n        const ctx = _canvas.getContext('2d');\n        ctx.drawImage(texture.image, minx, miny, dw, dh, 0, 0, dw, dh);\n        const d = ctx.getImageData(0, 0, dw, dh);\n\n        const result = [];\n        for (let i = 0; i < uv.length; i += 2) {\n            const ox = uv[i] - minx;\n            const oy = uv[i + 1] - miny;\n\n            // d is 4 bytes per pixel\n            result.push(THREE.Math.lerp(\n                layer.materialOptions.colorTextureElevationMinZ,\n                layer.materialOptions.colorTextureElevationMaxZ,\n                d.data[4 * oy * dw + 4 * ox] / 255));\n        }\n        if (uv.length === 2) {\n            return result[0];\n        } else {\n            return result;\n        }\n    }\n}\n\nfunction _convertUVtoTextureCoords(texture, u, v) {\n    const width = texture.image.width;\n    const height = texture.image.height;\n\n    const up = Math.max(0, u * width - 0.5);\n    const vp = Math.max(0, v * height - 0.5);\n\n    const u1 = Math.floor(up);\n    const u2 = Math.ceil(up);\n    const v1 = Math.floor(vp);\n    const v2 = Math.ceil(vp);\n\n    const wu = up - u1;\n    const wv = vp - v1;\n\n    return { u1, u2, v1, v2, wu, wv };\n}\n\nfunction _readTextureValueNearestFiltering(layer, texture, vertexU, vertexV) {\n    const coords = _convertUVtoTextureCoords(texture, vertexU, vertexV);\n\n    const u = (coords.wu <= 0) ? coords.u1 : coords.u2;\n    const v = (coords.wv <= 0) ? coords.v1 : coords.v2;\n\n    return _readTextureValueAt(layer, texture, u, v);\n}\n\nfunction _readTextureValueWithBilinearFiltering(layer, texture, vertexU, vertexV) {\n    const coords = _convertUVtoTextureCoords(texture, vertexU, vertexV);\n\n    const [z11, z21, z12, z22] = _readTextureValueAt(layer, texture,\n        coords.u1, coords.v1,\n        coords.u2, coords.v1,\n        coords.u1, coords.v2,\n        coords.u2, coords.v2);\n\n    // horizontal filtering\n    const zu1 = THREE.Math.lerp(z11, z21, coords.wu);\n    const zu2 = THREE.Math.lerp(z12, z22, coords.wu);\n    // then vertical filtering\n    return THREE.Math.lerp(zu1, zu2, coords.wv);\n}\n\n\nfunction _readZFast(layer, texture, uv) {\n    return _readTextureValueNearestFiltering(layer, texture, uv.x, uv.y);\n}\n\nfunction _readZCorrect(layer, texture, uv, tileDimensions, tileOwnerDimensions) {\n    // We need to emulate the vertex shader code that does 2 thing:\n    //   - interpolate (u, v) between triangle vertices: u,v will be multiple of 1/nsegments\n    //     (for now assume nsegments == 16)\n    //   - read elevation texture at (u, v) for\n\n    // Determine u,v based on the vertices count.\n    // 'modulo' is the gap (in [0, 1]) between 2 successive vertices in the geometry\n    // e.g if you have 5 vertices, the only possible values for u (or v) are: 0, 0.25, 0.5, 0.75, 1\n    // so modulo would be 0.25\n    // note: currently the number of segments is hard-coded to 16 (see TileProvider) => 17 vertices\n    const modulo = (tileDimensions.x / tileOwnerDimensions.x) / (17 - 1);\n    let u = Math.floor(uv.x / modulo) * modulo;\n    let v = Math.floor(uv.y / modulo) * modulo;\n\n    if (u == 1) {\n        u -= modulo;\n    }\n    if (v == 1) {\n        v -= modulo;\n    }\n\n    // Build 4 vertices, 3 of them will be our triangle:\n    //    11---21\n    //    |   / |\n    //    |  /  |\n    //    | /   |\n    //    21---22\n    const u1 = u;\n    const u2 = u + modulo;\n    const v1 = v;\n    const v2 = v + modulo;\n\n    // Our multiple z-value will be weigh-blended, depending on the distance of the real point\n    // so lu (resp. lv) are the weight. When lu -> 0 (resp. 1) the final value -> z at u1 (resp. u2)\n    const lu = (uv.x - u) / modulo;\n    const lv = (uv.y - v) / modulo;\n\n\n    // Determine if we're going to read the vertices from the top-left or lower-right triangle\n    // (low-right = on the line 21-22 or under the diagonal lu = 1 - lv)\n    const lowerRightTriangle = (lv == 1) || lu / (1 - lv) >= 1;\n\n    const tri = new THREE.Triangle(\n        new THREE.Vector3(u1, v2),\n        new THREE.Vector3(u2, v1),\n        lowerRightTriangle ? new THREE.Vector3(u2, v2) : new THREE.Vector3(u1, v1));\n\n    // bary holds the respective weight of each vertices of the triangles\n    const bary = tri.barycoordFromPoint(new THREE.Vector3(uv.x, uv.y));\n\n    // read the 3 interesting values\n    const z1 = _readTextureValueWithBilinearFiltering(layer, texture, tri.a.x, tri.a.y);\n    const z2 = _readTextureValueWithBilinearFiltering(layer, texture, tri.b.x, tri.b.y);\n    const z3 = _readTextureValueWithBilinearFiltering(layer, texture, tri.c.x, tri.c.y);\n\n    // Blend with bary\n    return z1 * bary.x + z2 * bary.y + z3 * bary.z;\n}\n\nconst temp = {\n    v: new THREE.Vector3(),\n    coord1: new Coordinates('EPSG:4978'),\n    coord2: new Coordinates('EPSG:4978'),\n    offset: new THREE.Vector2(),\n};\n\nfunction _readZ(layer, method, coord, nodes, cache) {\n    const pt = coord.as(layer.extent.crs(), temp.coord1);\n\n    let tileWithValidElevationTexture = null;\n    // first check in cache\n    if (cache && cache.tile && cache.tile.material) {\n        tileWithValidElevationTexture = tileAt(pt, cache.tile);\n    }\n    for (let i = 0; !tileWithValidElevationTexture && i < nodes.length; i++) {\n        tileWithValidElevationTexture = tileAt(pt, nodes[i]);\n    }\n\n    if (!tileWithValidElevationTexture) {\n        // failed to find a tile, abort\n        return;\n    }\n\n    const tile = tileWithValidElevationTexture;\n    const src = tileWithValidElevationTexture.getLayerTextures(l_ELEVATION)[0];\n\n    // check cache value if existing\n    if (cache) {\n        if (cache.id === src.id && cache.version === src.version) {\n            return { coord: pt, texture: src, tile };\n        }\n    }\n\n    // Assuming that tiles are split in 4 children, we lookup the parent that\n    // really owns this texture\n    const stepsUpInHierarchy = Math.round(Math.log2(1.0 /\n        tileWithValidElevationTexture.material.offsetScale[l_ELEVATION][0].z));\n    for (let i = 0; i < stepsUpInHierarchy; i++) {\n        tileWithValidElevationTexture = tileWithValidElevationTexture.parent;\n    }\n\n    // offset = offset from top-left\n    const offset = pt.offsetInExtent(tileWithValidElevationTexture.extent, temp.offset);\n\n    // At this point we have:\n    //   - tileWithValidElevationTexture.texture.image which is the current image\n    //     used for rendering\n    //   - offset which is the offset in this texture for the coordinate we're\n    //     interested in\n    // We now have 2 options:\n    //   - the fast one: read the value of tileWithValidElevationTexture.texture.image\n    //     at (offset.x, offset.y) and we're done\n    //   - the correct one: emulate the vertex shader code\n    if (method == PRECISE_READ_Z) {\n        pt._values[2] = _readZCorrect(layer, src, offset, tile.extent.dimensions(), tileWithValidElevationTexture.extent.dimensions());\n    } else {\n        pt._values[2] = _readZFast(layer, src, offset);\n    }\n    return { coord: pt, texture: src, tile };\n}\n\n\nfunction _updateVector3(layer, method, nodes, vecCRS, vec, offset, matrices = {}, coords, cache) {\n    const coord = coords || new Coordinates(vecCRS);\n    if (matrices.worldFromLocal) {\n        coord.set(vecCRS, temp.v.copy(vec).applyMatrix4(matrices.worldFromLocal));\n    } else {\n        coord.set(vecCRS, vec);\n    }\n    const result = _readZ(layer, method, coord, nodes, cache);\n    if (result) {\n        result.coord._values[2] += offset;\n        result.coord.as(vecCRS, temp.coord2).xyz(vec);\n        if (matrices.localFromWorld) {\n            vec.applyMatrix4(matrices.localFromWorld);\n        }\n        return { id: result.texture.id, version: result.texture.version, tile: result.tile };\n    }\n}\n\n"]}