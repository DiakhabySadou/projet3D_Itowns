'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _LayerUpdateState = require('../Core/Layer/LayerUpdateState');

var _LayerUpdateState2 = _interopRequireDefault(_LayerUpdateState);

var _CancelledCommandException = require('../Core/Scheduler/CancelledCommandException');

var _CancelledCommandException2 = _interopRequireDefault(_CancelledCommandException);

var _ObjectRemovalHelper = require('./ObjectRemovalHelper');

var _ObjectRemovalHelper2 = _interopRequireDefault(_ObjectRemovalHelper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function applyOffset(obj, offset) {
    if (obj.geometry) {
        if (obj.geometry instanceof THREE.BufferGeometry) {
            for (var i = 0; i < obj.geometry.attributes.position.count; i++) {
                obj.geometry.attributes.position.array[3 * i] += offset.x;
                obj.geometry.attributes.position.array[3 * i + 1] += offset.y;
                obj.geometry.attributes.position.array[3 * i + 2] += offset.z;
            }
            obj.geometry.attributes.position.needsUpdate = true;
        } else {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)(obj.geometry.vertices), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var v = _step.value;

                    v.add(offset);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            obj.geometry.verticesNeedUpdate = true;
        }
    }
    obj.children.forEach(function (c) {
        return applyOffset(c, offset);
    });
}

exports.default = {
    update: function update(context, layer, node) {
        if (!node.parent && node.children.length) {
            // if node has been removed dispose three.js resource
            _ObjectRemovalHelper2.default.removeChildrenAndCleanupRecursively(layer.id, node);
            return;
        }
        if (!node.visible) {
            return;
        }

        var features = node.children.filter(function (n) {
            return n.layer == layer.id;
        });
        if (features.length > 0) {
            return features;
        }

        if (!layer.tileInsideLimit(node, layer)) {
            return;
        }

        if (node.layerUpdateState[layer.id] === undefined) {
            node.layerUpdateState[layer.id] = new _LayerUpdateState2.default();
        }

        var ts = Date.now();

        if (!node.layerUpdateState[layer.id].canTryUpdate(ts)) {
            return;
        }

        node.layerUpdateState[layer.id].newTry();

        var command = {
            layer: layer,
            view: context.view,
            threejsLayer: layer.threejsLayer,
            requester: node
        };

        context.scheduler.execute(command).then(function (result) {
            // if request return empty json, WFS_Provider.getFeatures return undefined
            if (result) {
                // call onMeshCreated callback if needed
                if (layer.onMeshCreated) {
                    layer.onMeshCreated(result);
                }

                node.layerUpdateState[layer.id].success();
                if (!node.parent) {
                    _ObjectRemovalHelper2.default.removeChildrenAndCleanupRecursively(layer.id, result);
                    return;
                }
                // We don't use node.matrixWorld here, because feature coordinates are
                // expressed in crs coordinates (which may be different than world coordinates,
                // if node's layer is attached to an Object with a non-identity transformation)
                var tmp = node.extent.center().as(context.view.referenceCrs).xyz().negate();
                applyOffset(result, tmp);

                result.layer = layer.id;
                node.add(result);
                node.updateMatrixWorld();
            } else {
                node.layerUpdateState[layer.id].failure(1, true);
            }
        }, function (err) {
            if (err instanceof _CancelledCommandException2.default) {
                node.layerUpdateState[layer.id].success();
            } else if (err instanceof SyntaxError) {
                node.layerUpdateState[layer.id].failure(0, true);
            } else {
                node.layerUpdateState[layer.id].failure(Date.now());
                setTimeout(node.layerUpdateState[layer.id].secondsUntilNextTry() * 1000, function () {
                    context.view.notifyChange(false);
                });
            }
        });
    }
};