{"version":3,"sources":["../../src/Process/LayeredMaterialNodeProcessing.js"],"names":["refinementCommandCancellationFn","updateLayeredMaterialNodeImagery","updateLayeredMaterialNodeElevation","MAX_RETRY","initNodeImageryTexturesFromParent","node","parent","layer","material","getColorLayerLevelById","id","coords","getCoordsForLayer","offsetTextures","getLayerTextureOffset","textureIndex","c","getLayerTextures","texture","isInside","result","offsetToParent","textures","offsetScale","index","indexOfColorLayer","layerTexturesCount","length","loadedTexturesCount","initNodeElevationTextureFromParent","getElevationLayerLevel","pitch","elevation","useMinMaxFromParent","level","zoom","ioDXBIL","computeMinMaxElevation","image","data","min","max","setTextureElevation","elevationLayersId","getIndiceWithPitch","i","w","currentY","Math","floor","newX","x","z","newY","y","newIndice","insertSignificantValuesFromParent","textureParent","tData","l","noDataValue","nodeCommandQueuePriorityFunction","isDisplayed","cmd","requester","force","type","targetLevel","checkNodeElevationTextureValidity","sqrt","context","layerUpdateState","undefined","tileInsideLimit","noTextureParentOutsideLimit","getIndexLayerColor","noMoreUpdatePossible","texturesCount","tileTextureCount","paramMaterial","tileMT","options","tileMatrixSet","crs","visible","opacity","fx","idLayer","pushLayer","imageryLayers","view","getLayers","sequence","getColorLayersIdOrderedBySequence","setSequence","layerIndex","setLayerVisibility","setLayerOpacity","canTryUpdate","canTileTextureBeImproved","isColorLayerDownscaled","frozen","currentLevel","updateStrategy","newTry","command","priority","earlyDropFunction","scheduler","execute","then","Array","isArray","setTexturesLayer","success","err","console","warn","definitiveError","errorCount","failure","Date","now","window","setTimeout","notifyChange","secondsUntilNextTry","ts","currentElevation","resolve","push","terrain","flipY","needsUpdate"],"mappings":"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","file":"LayeredMaterialNodeProcessing.js","sourcesContent":["import { l_ELEVATION, l_COLOR, EMPTY_TEXTURE_ZOOM } from '../Renderer/LayeredMaterialConstants';\nimport { chooseNextLevelToFetch } from '../Core/Layer/LayerUpdateStrategy';\nimport LayerUpdateState from '../Core/Layer/LayerUpdateState';\nimport { ImageryLayers } from '../Core/Layer/Layer';\nimport CancelledCommandException from '../Core/Scheduler/CancelledCommandException';\nimport OGCWebServiceHelper, { SIZE_TEXTURE_TILE } from '../Core/Scheduler/Providers/OGCWebServiceHelper';\n\n// max retry loading before changing the status to definitiveError\nconst MAX_RETRY = 4;\n\nfunction initNodeImageryTexturesFromParent(node, parent, layer) {\n    if (parent.material && parent.material.getColorLayerLevelById(layer.id) > EMPTY_TEXTURE_ZOOM) {\n        const coords = node.getCoordsForLayer(layer);\n        const offsetTextures = node.material.getLayerTextureOffset(layer.id);\n\n        let textureIndex = offsetTextures;\n        for (const c of coords) {\n            for (const texture of parent.material.getLayerTextures(l_COLOR, layer.id)) {\n                if (c.isInside(texture.coords)) {\n                    const result = c.offsetToParent(texture.coords);\n                    node.material.textures[l_COLOR][textureIndex] = texture;\n                    node.material.offsetScale[l_COLOR][textureIndex] = result;\n                    textureIndex++;\n                    break;\n                }\n            }\n        }\n\n        if (__DEBUG__) {\n            if ((textureIndex - offsetTextures) != coords.length) {\n                /* eslint-disable */\n                console.error(`non-coherent result ${textureIndex} ${offsetTextures} vs ${coords.length}. ${coords}`);\n                /* eslint-enable */\n            }\n        }\n        const index = node.material.indexOfColorLayer(layer.id);\n        node.material.layerTexturesCount[index] = coords.length;\n        node.material.loadedTexturesCount[l_COLOR] += coords.length;\n    }\n}\n\nfunction initNodeElevationTextureFromParent(node, parent, layer) {\n    // Inherit parent's elevation texture. Note that contrary to color layers the elevation level of the\n    // node might not be EMPTY_TEXTURE_ZOOM in this init function. That's because we can have\n    // multiple elevation layers (thus multiple calls to initNodeElevationTextureFromParent) but a given\n    // node can only use 1 elevation texture\n    if (parent.material && parent.material.getElevationLayerLevel() > node.material.getElevationLayerLevel()) {\n        const coords = node.getCoordsForLayer(layer);\n\n        const texture = parent.material.textures[l_ELEVATION][0];\n        const pitch = coords[0].offsetToParent(parent.material.textures[l_ELEVATION][0].coords);\n        const elevation = {\n            texture,\n            pitch,\n        };\n\n        // If the texture resolution has a poor precision for this node, we don't\n        // extract min-max from the texture (too few information), we instead chose\n        // to use parent's min-max.\n        const useMinMaxFromParent = node.level - texture.coords.zoom > 6;\n        if (!useMinMaxFromParent) {\n            const { min, max } = OGCWebServiceHelper.ioDXBIL.computeMinMaxElevation(\n                texture.image.data,\n                SIZE_TEXTURE_TILE, SIZE_TEXTURE_TILE,\n                pitch);\n            elevation.min = min;\n            elevation.max = max;\n        }\n\n        node.setTextureElevation(elevation);\n        node.material.elevationLayersId =\n            parent.material.elevationLayersId;\n    }\n}\n\nfunction getIndiceWithPitch(i, pitch, w) {\n    // Return corresponding indice in parent tile using pitch\n    const currentX = (i % w) / w;  // normalized\n    const currentY = Math.floor(i / w) / w; // normalized\n    const newX = pitch.x + currentX * pitch.z;\n    const newY = pitch.y + currentY * pitch.w;\n    const newIndice = Math.floor(newY * w) * w + Math.floor(newX * w);\n    return newIndice;\n}\n\nfunction insertSignificantValuesFromParent(texture, node, parent, layer) {\n    if (parent.material && parent.material.getElevationLayerLevel() > EMPTY_TEXTURE_ZOOM) {\n        const coords = node.getCoordsForLayer(layer);\n        const textureParent = parent.material.textures[l_ELEVATION][0];\n        const pitch = coords[0].offsetToParent(parent.material.textures[l_ELEVATION][0].coords);\n        const tData = texture.image.data;\n        const l = tData.length;\n\n        for (var i = 0; i < l; ++i) {\n            if (tData[i] === layer.noDataValue) {\n                tData[i] = textureParent.image.data[getIndiceWithPitch(i, pitch, 256)];\n            }\n        }\n    }\n}\n\nfunction nodeCommandQueuePriorityFunction(node) {\n    // We know that 'node' is visible because commands can only be\n    // issued for visible nodes.\n\n    // TODO: need priorization of displayed nodes\n    if (node.isDisplayed()) {\n        // Then prefer displayed() node over non-displayed one\n        return 100;\n    } else {\n        return 10;\n    }\n}\n\nexport function refinementCommandCancellationFn(cmd) {\n    if (!cmd.requester.parent || !cmd.requester.material) {\n        return true;\n    }\n    if (cmd.force) {\n        return false;\n    }\n\n    // Cancel the command if the tile already has a better texture.\n    // This is only needed for elevation layers, because we may have several\n    // concurrent layers but we can only use one texture.\n    if (cmd.layer.type == 'elevation' &&\n        cmd.targetLevel <= cmd.requester.material.getElevationLayerLevel()) {\n        return true;\n    }\n\n    return !cmd.requester.isDisplayed();\n}\n\nfunction checkNodeElevationTextureValidity(texture, noDataValue) {\n    // We check if the elevation texture has some significant values through corners\n    const tData = texture.image.data;\n    const l = tData.length;\n    return tData[0] > noDataValue &&\n           tData[l - 1] > noDataValue &&\n           tData[Math.sqrt(l) - 1] > noDataValue &&\n           tData[l - Math.sqrt(l)] > noDataValue;\n}\n\nexport function updateLayeredMaterialNodeImagery(context, layer, node) {\n    if (!node.parent) {\n        return;\n    }\n\n    const material = node.material;\n\n    // Initialisation\n    if (node.layerUpdateState[layer.id] === undefined) {\n        node.layerUpdateState[layer.id] = new LayerUpdateState();\n\n        if (!layer.tileInsideLimit(node, layer)) {\n            // we also need to check that tile's parent doesn't have a texture for this layer,\n            // because even if this tile is outside of the layer, it could inherit it's\n            // parent texture\n            if (!layer.noTextureParentOutsideLimit &&\n                node.parent &&\n                node.parent.material &&\n                node.parent.getIndexLayerColor &&\n                node.parent.getIndexLayerColor(layer.id) >= 0) {\n                // ok, we're going to inherit our parent's texture\n            } else {\n                node.layerUpdateState[layer.id].noMoreUpdatePossible();\n                return;\n            }\n        }\n\n        if (material.indexOfColorLayer(layer.id) === -1) {\n            const texturesCount = layer.tileTextureCount ?\n                layer.tileTextureCount(node, layer) : 1;\n\n            const paramMaterial = {\n                tileMT: layer.options.tileMatrixSet || node.getCoordsForLayer(layer)[0].crs(),\n                texturesCount,\n                visible: layer.visible,\n                opacity: layer.opacity,\n                fx: layer.fx,\n                idLayer: layer.id,\n            };\n\n            material.pushLayer(paramMaterial);\n            const imageryLayers = context.view.getLayers(l => l.type === 'color');\n            const sequence = ImageryLayers.getColorLayersIdOrderedBySequence(imageryLayers);\n            material.setSequence(sequence);\n\n            initNodeImageryTexturesFromParent(node, node.parent, layer);\n        }\n    }\n\n    // Node is hidden, no need to update it\n    if (!node.isDisplayed()) {\n        return;\n    }\n\n    // TODO: move this to defineLayerProperty() declaration\n    // to avoid mixing layer's network updates and layer's params\n    // Update material parameters\n    const layerIndex = material.indexOfColorLayer(layer.id);\n    material.setLayerVisibility(layerIndex, layer.visible);\n    material.setLayerOpacity(layerIndex, layer.opacity);\n\n    // An update is pending / or impossible -> abort\n    if (!layer.visible || !node.layerUpdateState[layer.id].canTryUpdate(ts)) {\n        return;\n    }\n\n\n    const ts = Date.now();\n    // does this tile needs a new texture?\n    if (layer.canTileTextureBeImproved) {\n        // if the layer has a custom method -> use it\n        if (!layer.canTileTextureBeImproved(layer, node)) {\n            node.layerUpdateState[layer.id].noMoreUpdatePossible();\n            return;\n        }\n    } else if (!node.isColorLayerDownscaled(layer)) {\n        // default decision method\n        node.layerUpdateState[layer.id].noMoreUpdatePossible();\n        return;\n    }\n\n    // is fetching data from this layer disabled?\n    if (layer.frozen) {\n        return;\n    }\n\n    const currentLevel = node.material.getColorLayerLevelById(layer.id);\n    const zoom = node.getCoordsForLayer(layer)[0].zoom || node.level;\n    const targetLevel = chooseNextLevelToFetch(layer.updateStrategy.type, node, zoom, currentLevel, layer);\n    if (targetLevel <= currentLevel) {\n        return;\n    }\n\n    node.layerUpdateState[layer.id].newTry();\n    const command = {\n        /* mandatory */\n        view: context.view,\n        layer,\n        requester: node,\n        priority: nodeCommandQueuePriorityFunction(node),\n        earlyDropFunction: refinementCommandCancellationFn,\n        targetLevel,\n    };\n\n    return context.scheduler.execute(command).then(\n        (result) => {\n            if (node.material === null) {\n                return;\n            }\n\n            if (Array.isArray(result)) {\n                node.setTexturesLayer(result, l_COLOR, layer.id);\n            } else if (result.texture) {\n                node.setTexturesLayer([result], l_COLOR, layer.id);\n            } else {\n                // TODO: null texture is probably an error\n                // Maybe add an error counter for the node/layer,\n                // and stop retrying after X attempts.\n            }\n\n            node.layerUpdateState[layer.id].success();\n\n            return result;\n        },\n        (err) => {\n            if (err instanceof CancelledCommandException) {\n                node.layerUpdateState[layer.id].success();\n            } else {\n                // eslint-disable-next-line no-console\n                console.warn('Imagery texture update error for', node, err);\n                const definitiveError = node.layerUpdateState[layer.id].errorCount > MAX_RETRY;\n                node.layerUpdateState[layer.id].failure(Date.now(), definitiveError);\n                if (!definitiveError) {\n                    window.setTimeout(() => {\n                        context.view.notifyChange(false, node);\n                    }, node.layerUpdateState[layer.id].secondsUntilNextTry() * 1000);\n                }\n            }\n        });\n}\n\nexport function updateLayeredMaterialNodeElevation(context, layer, node, force) {\n    if (!node.parent) {\n        return;\n    }\n    // TODO: we need either\n    //  - compound or exclusive layers\n    //  - support for multiple elevation layers\n\n    // Elevation is currently handled differently from color layers.\n    // This is caused by a LayeredMaterial limitation: only 1 elevation texture\n    // can be used (where a tile can have N textures x M layers)\n    const ts = Date.now();\n\n    const material = node.material;\n    let currentElevation = material.getElevationLayerLevel();\n\n    // If currentElevevation is EMPTY_TEXTURE_ZOOM but material.loadedTexturesCount[l_ELEVATION] is > 0\n    // means that we already tried and failed to download an elevation texture\n    if (currentElevation == EMPTY_TEXTURE_ZOOM && node.material.loadedTexturesCount[l_ELEVATION] > 0) {\n        return Promise.resolve();\n    }\n    if (layer.frozen && !force) {\n        return Promise.resolve();\n    }\n\n    if (node.layerUpdateState[layer.id] === undefined) {\n        node.layerUpdateState[layer.id] = new LayerUpdateState();\n        initNodeElevationTextureFromParent(node, node.parent, layer);\n        currentElevation = material.getElevationLayerLevel();\n    }\n\n    // does this tile needs a new texture?\n    if (layer.canTileTextureBeImproved) {\n        // if the layer has a custom method -> use it\n        if (!layer.canTileTextureBeImproved(layer, node)) {\n            node.layerUpdateState[layer.id].noMoreUpdatePossible();\n            return Promise.resolve();\n        }\n    }\n\n    if (!node.isDisplayed()) {\n        return Promise.resolve();\n    }\n\n    if (!node.layerUpdateState[layer.id].canTryUpdate(ts)) {\n        return Promise.resolve();\n    }\n\n    const c = node.getCoordsForLayer(layer)[0];\n    const zoom = c.zoom || node.level;\n    const targetLevel = chooseNextLevelToFetch(layer.updateStrategy.type, node, zoom, currentElevation, layer);\n\n    if (targetLevel <= currentElevation || !layer.tileInsideLimit(node, layer, targetLevel)) {\n        return Promise.resolve();\n    }\n\n    // TODO\n    if (material.elevationLayersId.length === 0) {\n        material.elevationLayersId.push(layer.id);\n    }\n    node.layerUpdateState[layer.id].newTry();\n\n    const command = {\n        /* mandatory */\n        view: context.view,\n        layer,\n        requester: node,\n        targetLevel,\n        priority: nodeCommandQueuePriorityFunction(node),\n        earlyDropFunction: refinementCommandCancellationFn,\n        force,\n    };\n\n    return context.scheduler.execute(command).then(\n        (terrain) => {\n            if (node.material === null) {\n                return;\n            }\n\n            // Do not apply the new texture if its level is < than the current one.\n            // This is only needed for elevation layers, because we may have several\n            // concurrent layers but we can only use one texture.\n            if (targetLevel <= node.material.getElevationLayerLevel()) {\n                node.layerUpdateState[layer.id].noMoreUpdatePossible();\n                return;\n            }\n\n            node.layerUpdateState[layer.id].success();\n\n            if (terrain.texture && terrain.texture.flipY) {\n                // DataTexture default to false, so make sure other Texture types\n                // do the same (eg image texture)\n                // See UV construction for more details\n                terrain.texture.flipY = false;\n                terrain.texture.needsUpdate = true;\n            }\n\n            if (terrain.texture && terrain.texture.image.data && !checkNodeElevationTextureValidity(terrain.texture, layer.noDataValue)) {\n                // Quick check to avoid using elevation texture with no data value\n                // If we have no data values, we use value from the parent tile\n                // We should later implement multi elevation layer to choose the one to use at each level\n                insertSignificantValuesFromParent(terrain.texture, node, node.parent, layer);\n            }\n\n            node.setTextureElevation(terrain);\n        },\n        (err) => {\n            if (err instanceof CancelledCommandException) {\n                node.layerUpdateState[layer.id].success();\n            } else {\n                // eslint-disable-next-line no-console\n                console.warn('Elevation texture update error for', node, err);\n                const definitiveError = node.layerUpdateState[layer.id].errorCount > MAX_RETRY;\n                node.layerUpdateState[layer.id].failure(Date.now(), definitiveError);\n                if (!definitiveError) {\n                    window.setTimeout(() => {\n                        context.view.notifyChange(false, node);\n                    }, node.layerUpdateState[layer.id].secondsUntilNextTry() * 1000);\n                }\n            }\n        });\n}\n"]}