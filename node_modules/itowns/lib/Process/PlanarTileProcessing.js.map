{"version":3,"sources":["../../src/Process/PlanarTileProcessing.js"],"names":["planarCulling","planarSubdivisionControl","frustumCullingOBB","node","camera","isBox3Visible","OBB","box3D","matrixWorld","_isTileNearCamera","tmp","copy","position","val","parent","localToWorld","sub","camera3D","length","geometry","boundingSphere","radius","_isTileNearCamera2","context","layer","maxSubdivisionLevel","level"],"mappings":";;;;;QAMgBA,a,GAAAA,a;QA8BAC,wB,GAAAA,wB;;AApChB;;AAEA,SAASC,iBAAT,CAA2BC,IAA3B,EAAiCC,MAAjC,EAAyC;AACrC,WAAOA,OAAOC,aAAP,CAAqBF,KAAKG,GAAL,GAAWC,KAAhC,EAAuCJ,KAAKG,GAAL,GAAWE,WAAlD,CAAP;AACH;;AAEM,SAASR,aAAT,CAAuBG,IAAvB,EAA6BC,MAA7B,EAAqC;AACxC,WAAO,CAACF,kBAAkBC,IAAlB,EAAwBC,MAAxB,CAAR;AACH;;AAED;;;;;;;;;;;;;;;;AAgBA,SAASK,iBAAT,GAA6B;AACzB,QAAMC,MAAM,oBAAZ;AACA,WAAO,UAA4BN,MAA5B,EAAoCD,IAApC,EAA0C;AAC7CO,YAAIC,IAAJ,CAASR,KAAKS,QAAd;AACA,YAAMC,MAAMV,KAAKW,MAAL,CAAYC,YAAZ,CAAyBL,GAAzB,EAA8BM,GAA9B,CAAkCZ,OAAOa,QAAP,CAAgBL,QAAlD,EAA4DM,MAA5D,KAAuEf,KAAKgB,QAAL,CAAcC,cAAd,CAA6BC,MAAhH;AACA,eAAOR,MAAM,CAAb;AACH,KAJD;AAKH;;AAED,IAAMS,qBAAqBb,mBAA3B;AACO,SAASR,wBAAT,CAAkCsB,OAAlC,EAA2CC,KAA3C,EAAkDrB,IAAlD,EAAwD;AAC3D,QAAIqB,MAAMC,mBAAN,IAA6BtB,KAAKuB,KAAtC,EAA6C;AACzC,eAAO,KAAP;AACH;;AAED,WAAOJ,mBAAmBC,QAAQnB,MAA3B,EAAmCD,IAAnC,CAAP;AACH","file":"PlanarTileProcessing.js","sourcesContent":["import { Vector3 } from 'three';\n\nfunction frustumCullingOBB(node, camera) {\n    return camera.isBox3Visible(node.OBB().box3D, node.OBB().matrixWorld);\n}\n\nexport function planarCulling(node, camera) {\n    return !frustumCullingOBB(node, camera);\n}\n\n/* function _isTileBigOnScreen(camera, node) {\n    const onScreen = camera.box3SizeOnScreen(node.geometry.OBB.box3D, node.matrixWorld);\n\n    // onScreen.x/y/z are [-1, 1] so divide by 2\n    // (so x = 0.4 means the object width on screen is 40% of the total screen width)\n    const dim = {\n        x: 0.5 * (onScreen.max.x - onScreen.min.x),\n        y: 0.5 * (onScreen.max.y - onScreen.min.y),\n    };\n\n    // subdivide if on-screen width (and resp. height) is bigger than 30% of the screen width (resp. height)\n    // TODO: the 30% value is arbitrary and needs to be configurable by the user\n    // TODO: we might want to use texture resolution here as well\n    return (dim.x >= 0.3 && dim.y >= 0.3);\n    } */\n\nfunction _isTileNearCamera() {\n    const tmp = new Vector3();\n    return function _itTileNearCamera2(camera, node) {\n        tmp.copy(node.position);\n        const val = node.parent.localToWorld(tmp).sub(camera.camera3D.position).length() / node.geometry.boundingSphere.radius;\n        return val < 4;\n    };\n}\n\nconst _isTileNearCamera2 = _isTileNearCamera();\nexport function planarSubdivisionControl(context, layer, node) {\n    if (layer.maxSubdivisionLevel <= node.level) {\n        return false;\n    }\n\n    return _isTileNearCamera2(context.camera, node);\n}\n"]}