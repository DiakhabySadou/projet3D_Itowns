{"version":3,"sources":["../../src/Process/FeatureProcessing.js"],"names":["THREE","applyOffset","obj","offset","geometry","BufferGeometry","i","attributes","position","count","array","x","y","z","needsUpdate","vertices","v","add","verticesNeedUpdate","children","forEach","c","update","context","layer","node","parent","length","removeChildrenAndCleanupRecursively","id","visible","features","filter","n","tileInsideLimit","layerUpdateState","undefined","ts","Date","now","canTryUpdate","newTry","command","view","threejsLayer","requester","scheduler","execute","then","result","onMeshCreated","success","tmp","extent","center","as","referenceCrs","xyz","negate","updateMatrixWorld","failure","err","SyntaxError","setTimeout","secondsUntilNextTry","notifyChange"],"mappings":"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","file":"FeatureProcessing.js","sourcesContent":["import * as THREE from 'three';\nimport LayerUpdateState from '../Core/Layer/LayerUpdateState';\nimport CancelledCommandException from '../Core/Scheduler/CancelledCommandException';\nimport ObjectRemovalHelper from './ObjectRemovalHelper';\n\nfunction applyOffset(obj, offset) {\n    if (obj.geometry) {\n        if (obj.geometry instanceof THREE.BufferGeometry) {\n            for (let i = 0; i < obj.geometry.attributes.position.count; i++) {\n                obj.geometry.attributes.position.array[3 * i] += offset.x;\n                obj.geometry.attributes.position.array[3 * i + 1] += offset.y;\n                obj.geometry.attributes.position.array[3 * i + 2] += offset.z;\n            }\n            obj.geometry.attributes.position.needsUpdate = true;\n        } else {\n            for (const v of obj.geometry.vertices) {\n                v.add(offset);\n            }\n            obj.geometry.verticesNeedUpdate = true;\n        }\n    }\n    obj.children.forEach(c => applyOffset(c, offset));\n}\n\nexport default {\n    update(context, layer, node) {\n        if (!node.parent && node.children.length) {\n            // if node has been removed dispose three.js resource\n            ObjectRemovalHelper.removeChildrenAndCleanupRecursively(layer.id, node);\n            return;\n        }\n        if (!node.visible) {\n            return;\n        }\n\n        const features = node.children.filter(n => n.layer == layer.id);\n        if (features.length > 0) {\n            return features;\n        }\n\n        if (!layer.tileInsideLimit(node, layer)) {\n            return;\n        }\n\n        if (node.layerUpdateState[layer.id] === undefined) {\n            node.layerUpdateState[layer.id] = new LayerUpdateState();\n        }\n\n        const ts = Date.now();\n\n        if (!node.layerUpdateState[layer.id].canTryUpdate(ts)) {\n            return;\n        }\n\n        node.layerUpdateState[layer.id].newTry();\n\n        const command = {\n            layer,\n            view: context.view,\n            threejsLayer: layer.threejsLayer,\n            requester: node,\n        };\n\n        context.scheduler.execute(command).then((result) => {\n            // if request return empty json, WFS_Provider.getFeatures return undefined\n            if (result) {\n                // call onMeshCreated callback if needed\n                if (layer.onMeshCreated) {\n                    layer.onMeshCreated(result);\n                }\n\n                node.layerUpdateState[layer.id].success();\n                if (!node.parent) {\n                    ObjectRemovalHelper.removeChildrenAndCleanupRecursively(layer.id, result);\n                    return;\n                }\n                // We don't use node.matrixWorld here, because feature coordinates are\n                // expressed in crs coordinates (which may be different than world coordinates,\n                // if node's layer is attached to an Object with a non-identity transformation)\n                const tmp = node.extent.center().as(context.view.referenceCrs).xyz().negate();\n                applyOffset(result, tmp);\n\n                result.layer = layer.id;\n                node.add(result);\n                node.updateMatrixWorld();\n            } else {\n                node.layerUpdateState[layer.id].failure(1, true);\n            }\n        },\n        (err) => {\n            if (err instanceof CancelledCommandException) {\n                node.layerUpdateState[layer.id].success();\n            } else if (err instanceof SyntaxError) {\n                node.layerUpdateState[layer.id].failure(0, true);\n            } else {\n                node.layerUpdateState[layer.id].failure(Date.now());\n                setTimeout(node.layerUpdateState[layer.id].secondsUntilNextTry() * 1000,\n                    () => {\n                        context.view.notifyChange(false);\n                    });\n            }\n        });\n    },\n};\n"]}