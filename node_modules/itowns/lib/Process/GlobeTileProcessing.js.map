{"version":3,"sources":["../../src/Process/GlobeTileProcessing.js"],"names":["preGlobeUpdate","globeCulling","globeSubdivisionControl","globeSchemeTileWMTS","computeTileZoomFromDistanceCamera","computeDistanceCameraFromTileZoom","THREE","cV","Vector3","vhMagnitudeSquared","SSE_SUBDIVISION_THRESHOLD","worldToScaledEllipsoid","Matrix4","_preSSE","view","canvasSize","mainLoop","gfxEngine","getWindowSize","hypotenuse","length","radAngle","camera","camera3D","fov","Math","PI","HYFOV","atan","tan","x","context","layer","getInverse","object3d","matrixWorld","premultiply","makeScale","y","z","copy","position","applyMatrix4","lengthSq","preSSE","pointHorizonCulling","pt","vT","sub","vtMagnitudeSquared","dot","isOccluded","horizonCulling","node","points","OBB","pointsWorld","point","clone","frustumCullingOBB","isBox3Visible","box3D","minLevelForHorizonCulling","level","computeNodeSSE","v","setFromMatrixScale","boundingSphereCenter","addVectors","geometry","boundingSphere","center","boundingSphereOffset","distance","max","distanceTo","radius","geometricError","minLevel","maxLevel","sseThreshold","sse","globeSchemeTile0","globeSchemeTile1","type","schemeT","push","PI_OV_TWO","TWO_PI","bbox","_internalStorageUnit","RADIAN","sizeEllipsoid","preSinus","sinus","zoom","log","asin","delta","pow","circleChord","sin","isNaN","round"],"mappings":"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","file":"GlobeTileProcessing.js","sourcesContent":["import * as THREE from 'three';\nimport MathExt from '../Core/Math/MathExtended';\nimport { UNIT, ellipsoidSizes } from '../Core/Geographic/Coordinates';\nimport { SIZE_TEXTURE_TILE } from '../Core/Scheduler/Providers/OGCWebServiceHelper';\nimport Extent from '../Core/Geographic/Extent';\n\nconst cV = new THREE.Vector3();\nlet vhMagnitudeSquared;\n\nlet SSE_SUBDIVISION_THRESHOLD;\n\nconst worldToScaledEllipsoid = new THREE.Matrix4();\n\nfunction _preSSE(view) {\n    const canvasSize = view.mainLoop.gfxEngine.getWindowSize();\n    const hypotenuse = canvasSize.length();\n    const radAngle = view.camera.camera3D.fov * Math.PI / 180;\n\n     // TODO: not correct -> see new preSSE\n    // const HFOV = 2.0 * Math.atan(Math.tan(radAngle * 0.5) / context.camera.ratio);\n    const HYFOV = 2.0 * Math.atan(Math.tan(radAngle * 0.5) * hypotenuse / canvasSize.x);\n\n    return hypotenuse * (2.0 * Math.tan(HYFOV * 0.5));\n}\n\nexport function preGlobeUpdate(context, layer) {\n    // We're going to use the method described here:\n    //    https://cesiumjs.org/2013/04/25/Horizon-culling/\n    // This method assumes that the globe is a unit sphere at 0,0,0 so\n    // we setup a world-to-scaled-ellipsoid matrix4\n    worldToScaledEllipsoid.getInverse(layer.object3d.matrixWorld);\n    worldToScaledEllipsoid.premultiply(\n        new THREE.Matrix4().makeScale(\n            1 / ellipsoidSizes().x,\n            1 / ellipsoidSizes().y,\n            1 / ellipsoidSizes().z));\n\n    // pre-horizon culling\n    // cV is camera's position in worldToScaledEllipsoid system\n    cV.copy(context.camera.camera3D.position).applyMatrix4(worldToScaledEllipsoid);\n    vhMagnitudeSquared = cV.lengthSq() - 1.0;\n\n    // pre-sse\n    context.camera.preSSE = _preSSE(context.view);\n}\n\nfunction pointHorizonCulling(pt) {\n    // see https://cesiumjs.org/2013/04/25/Horizon-culling/\n    const vT = pt.applyMatrix4(worldToScaledEllipsoid).sub(cV);\n\n    const vtMagnitudeSquared = vT.lengthSq();\n\n    const dot = -vT.dot(cV);\n\n    const isOccluded =\n        vhMagnitudeSquared < dot &&\n        vhMagnitudeSquared < ((dot * dot) / vtMagnitudeSquared);\n\n    return isOccluded;\n}\n\nfunction horizonCulling(node) {\n    const points = node.OBB().pointsWorld;\n\n    for (const point of points) {\n        if (!pointHorizonCulling(point.clone())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction frustumCullingOBB(node, camera) {\n    return camera.isBox3Visible(node.OBB().box3D, node.OBB().matrixWorld);\n}\n\nexport function globeCulling(minLevelForHorizonCulling) {\n    return function _globeCulling(node, camera) {\n        return !(frustumCullingOBB(node, camera) && (node.level < minLevelForHorizonCulling || horizonCulling(node)));\n    };\n}\n\nfunction computeNodeSSE(camera, node) {\n    const v = new THREE.Vector3();\n    v.setFromMatrixScale(node.matrixWorld);\n    const boundingSphereCenter = new THREE.Vector3().addVectors(node.geometry.boundingSphere.center, node.boundingSphereOffset).applyMatrix4(node.matrixWorld);\n    const distance = Math.max(\n        0.0,\n        camera.camera3D.position.distanceTo(boundingSphereCenter) - node.geometry.boundingSphere.radius * v.x);\n\n    // Removed because is false computation, it doesn't consider the altitude of node\n    // Added small oblique weight (distance is not enough, tile orientation is needed)\n    /*\n    var altiW = node.bbox.top() === 10000 ? 0. : node.bbox.bottom() / 10000.;\n    var dotProductW = Math.min(altiW + Math.abs(this.camera3D.getWorldDirection().dot(node.centerSphere.clone().normalize())), 1.);\n    if (this.camera3D.position.length() > 6463300) dotProductW = 1;\n    var SSE = Math.sqrt(dotProductW) * this.preSSE * (node.geometricError / distance);\n    */\n\n    // TODO: node.geometricError is computed using a hardcoded 18 level\n    // The computation of node.geometricError is surely false\n    return camera.preSSE * (node.geometricError * v.x) / distance;\n}\n\nexport function globeSubdivisionControl(minLevel, maxLevel, sseThreshold) {\n    SSE_SUBDIVISION_THRESHOLD = sseThreshold;\n    return function _globeSubdivisionControl(context, layer, node) {\n        if (node.level < minLevel) {\n            return true;\n        }\n        if (maxLevel <= node.level) {\n            return false;\n        }\n\n        const sse = computeNodeSSE(context.camera, node);\n\n        return SSE_SUBDIVISION_THRESHOLD < sse;\n    };\n}\n\n// bbox longitude(0,360),latitude(-90,90)\nexport const globeSchemeTile0 = 0;\n// bbox longitude(-180,180),latitude(-90,90)\nexport const globeSchemeTile1 = 1;\n\nexport function globeSchemeTileWMTS(type) {\n    const schemeT = [];\n\n    if (type === 0) {\n        // bbox longitude(0,360),latitude(-90,90)\n        schemeT.push(new Extent('EPSG:4326', 0, MathExt.PI, -MathExt.PI_OV_TWO, MathExt.PI_OV_TWO));\n        schemeT.push(new Extent('EPSG:4326', MathExt.PI, MathExt.TWO_PI, -MathExt.PI_OV_TWO, MathExt.PI_OV_TWO));\n    } else if (type == 1) {\n        // bbox longitude(-180,180),latitude(-90,90)\n        schemeT.push(new Extent('EPSG:4326', -MathExt.PI, 0, -MathExt.PI_OV_TWO, MathExt.PI_OV_TWO));\n        schemeT.push(new Extent('EPSG:4326', 0, MathExt.PI, -MathExt.PI_OV_TWO, MathExt.PI_OV_TWO));\n    }\n    // store internally as Radians to avoid doing too much deg->rad conversions\n    for (const bbox of schemeT) {\n        bbox._internalStorageUnit = UNIT.RADIAN;\n    }\n    return schemeT;\n}\n\nexport function computeTileZoomFromDistanceCamera(distance, view) {\n    const sizeEllipsoid = ellipsoidSizes().x;\n    const preSinus = SIZE_TEXTURE_TILE * (SSE_SUBDIVISION_THRESHOLD * 0.5) / view.camera.preSSE / sizeEllipsoid;\n\n    let sinus = distance * preSinus;\n    let zoom = Math.log(Math.PI / (2.0 * Math.asin(sinus))) / Math.log(2);\n\n    const delta = Math.PI / Math.pow(2, zoom);\n    const circleChord = 2.0 * sizeEllipsoid * Math.sin(delta * 0.5);\n    const radius = circleChord * 0.5;\n\n    // adjust with bounding sphere rayon\n    sinus = (distance - radius) * preSinus;\n    zoom = Math.log(Math.PI / (2.0 * Math.asin(sinus))) / Math.log(2);\n\n    return isNaN(zoom) ? 0 : Math.round(zoom);\n}\n\nexport function computeDistanceCameraFromTileZoom(zoom, view) {\n    const delta = Math.PI / Math.pow(2, zoom);\n    const circleChord = 2.0 * ellipsoidSizes().x * Math.sin(delta * 0.5);\n    const radius = circleChord * 0.5;\n    const error = radius / SIZE_TEXTURE_TILE;\n\n    return view.camera.preSSE * error / (SSE_SUBDIVISION_THRESHOLD * 0.5) + radius;\n}\n"]}