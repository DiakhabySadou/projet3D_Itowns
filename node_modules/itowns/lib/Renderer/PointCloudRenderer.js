'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

var _BasicVS = "varying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";

var _BasicVS2 = _interopRequireDefault(_BasicVS);

var _EDLPassOneFS = "#include <packing>\nuniform sampler2D depthTexture;\nuniform vec2 resolution;\nuniform float strength;\nuniform float cameraNear;\nuniform float cameraFar;\n\nuniform int n;\nuniform int directions;\nuniform float radius;\n\nvarying vec2 vUv;\n\nfloat readDepth (float fragCoordZ) {\n    float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n    return log2(viewZToOrthographicDepth(viewZ, cameraNear, cameraFar));\n}\n\n// inspiration from https://tel.archives-ouvertes.fr/tel-00438464/document and Potree\nvoid main() {\n    float fragCoordZ = texture2D(depthTexture, vUv).x;\n    if (fragCoordZ == 1.0) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    float zp = readDepth(fragCoordZ);\n    float s = 0.0;\n\n    const int max_k = 16;\n    const int max_n = 4;\n\n    float step = 2.0 * 3.1415926 / float(directions);\n    for (int i=0; i<max_k; i++) {\n        if (i == directions) {\n            // workaround for loop index cannot be compared with non-constant expression\n            break;\n        }\n        for (int j=1; j<=max_n; j++) {\n            if (j > n) {\n                // workaround for loop index cannot be compared with non-constant expression\n                break;\n            }\n            float distance = radius * float(j);\n            float rad = float(i) * step;\n            vec2 offset = vec2(\n                cos(rad) * distance,\n                sin(rad) * distance) / resolution;\n\n            float fz = texture2D(depthTexture, vUv + offset).x;\n            float zq = readDepth(fz);\n\n            s += max(0.0, -(zq - zp) / distance);\n        }\n    }\n    s = s / float(directions) / float(n);\n\n    float A = 300.0 * strength;\n    s = exp(-s * A);\n    gl_FragColor = vec4(s, s, s, 1.0);\n}\n";

var _EDLPassOneFS2 = _interopRequireDefault(_EDLPassOneFS);

var _EDLPassTwoFS = "uniform sampler2D depthTexture;\nuniform sampler2D textureColor;\nuniform sampler2D textureEDL;\n\nvarying vec2 vUv;\nuniform float opacity;\n\nvoid main() {\n    float edl = texture2D(textureEDL, vUv).r;\n    // edl is 0 => no neighbours, so disable EDL to avoid drawing a black\n    // circle around individual points\n    vec4 source = texture2D(textureColor, vUv);\n    if (edl == 0.0) {\n        discard;\n    } else {\n        gl_FragColor = vec4(source.rgb * edl, source.a);\n        gl_FragDepthEXT = texture2D(depthTexture, vUv).r;\n    }\n}\n";

var _EDLPassTwoFS2 = _interopRequireDefault(_EDLPassTwoFS);

var _OcclusionFS = "uniform sampler2D depthTexture;\nuniform sampler2D colorTexture;\n\nvarying vec2 vUv;\n\nuniform float m43;\nuniform float m33;\nuniform vec2 resolution;\nuniform mat4 invPersMatrix;\n\nuniform float threshold;\nuniform bool showRemoved;\nuniform vec3 clearColor;\n\nuniform float opacity;\n\nvec3 unproject (vec2 ptex, float d)\n{\n    vec2 pndc = ptex * 2.0 - 1.0;\n    vec3 pray = (invPersMatrix * vec4(pndc, 1.0, 1.0)).xyz;\n    return d * pray;\n}\n\n\nfloat zView(float depth) {\n    // http://www.derschmale.com/2014/01/26/reconstructing-positions-from-the-depth-buffer/\n    float zndc = 2.0 * depth - 1.0;\n    return - m43 / (zndc + m33);\n}\n\nvoid main() {\n   float depth = texture2D(depthTexture, vUv).x;\n\n    if (depth < 1.0) {\n        float sectors[8];\n        for (int i=0; i<8; i++) {\n            sectors[i] = -1.0;\n        }\n\n        vec3 p0 = unproject(gl_FragCoord.xy / resolution, -zView(depth));\n        vec3 v = -normalize(p0);\n\n        const int kernelSize = 7;\n        for (int i=-kernelSize; i<=kernelSize; i++) {\n            for (int j=-kernelSize; j<=kernelSize; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                float d = texture2D(\n                    depthTexture,\n                    vUv + vec2(float(i) / resolution.x, float(j) / resolution.y)).x;\n\n                if (d == 1.0) {\n                    continue;\n                }\n\n                vec2 coord = (gl_FragCoord.xy + vec2(i, j)) / resolution;\n                vec3 pij = unproject(coord, - zView(d));\n                vec3 c = normalize(pij - p0);\n                float test = dot(v, c);\n\n                if (i >= 0) {\n                    if(abs(float(j)) <= abs(float(i))) {\n                        if (j >= 0) {\n                            sectors[0] = max(sectors[0], test);\n                        }\n                        if (j <= 0) {\n                            sectors[7] = max(sectors[7], test);\n                        }\n                    }\n                    if(abs(float(j)) >= abs(float(i))) {\n                        if (j >= 0) {\n                            sectors[1] = max(sectors[1], test);\n                        }\n                        if (j <= 0) {\n                            sectors[6] = max(sectors[6], test);\n                        }\n                    }\n                }\n                if (i <= 0) {\n                    if(abs(float(j)) <= abs(float(i))) {\n                        if (j >= 0) {\n                            sectors[3] = max(sectors[3], test);\n                        }\n                        if (j <= 0) {\n                            sectors[4] = max(sectors[4], test);\n                        }\n                    }\n                    if(abs(float(j)) >= abs(float(i))) {\n                        if (j >= 0) {\n                            sectors[2] = max(sectors[2], test);\n                        }\n                        if (j <= 0) {\n                            sectors[5] = max(sectors[5], test);\n                        }\n                    }\n                }\n            }\n        }\n\n        bool visible = true;\n        float m = 0.0;\n        for (int i=0; i< 8 ;i++) {\n            m += (1.0 + sectors[i]) * 0.5;\n        }\n        m /= 8.0;\n\n        if (m < threshold) {\n            gl_FragColor = texture2D(colorTexture, vUv);\n            gl_FragDepthEXT = depth;\n        } else if (showRemoved) {\n            gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n            gl_FragDepthEXT = 1.0;\n        } else {\n            gl_FragColor.a = 0.0;\n            gl_FragDepthEXT = 1.0;\n        }\n    } else {\n        gl_FragColor.a = 0.0;\n        gl_FragDepthEXT = 1.0;\n    }\n}\n";

var _OcclusionFS2 = _interopRequireDefault(_OcclusionFS);

var _InpaintingFS = "uniform sampler2D depthTexture;\nuniform sampler2D colorTexture;\n\nvarying vec2 vUv;\n\nuniform vec2 resolution;\nuniform float depth_contrib;\nuniform float opacity;\n\nvoid main() {\n    float depth = texture2D(depthTexture, vUv).x;\n    gl_FragDepthEXT = depth;\n\n    // non empty pixel\n    if (depth < 1.0) {\n        gl_FragColor = texture2D(colorTexture, vUv);\n        return;\n    }\n\n    // empty pixel\n    {\n        float total_weight = 0.0;\n        vec4 averageColor = vec4(0.0, 0.0, 0.0, 0.0);\n        float averageDepth = 0.;\n        const int kernel = 3;\n        for (int i=-kernel; i<=kernel; i++) {\n            for (int j=-kernel; j<=kernel; j++) {\n                if (i == 0 && j == 0) continue;\n                vec2 uv = vUv + vec2(float(i) / resolution.x, float(j) / resolution.y);\n                float d = texture2D(depthTexture, uv).x;\n\n                if (d < 1.0) {\n                    float r_ij = sqrt(float(i*i + j*j));\n                    float weight_ij = (float(kernel) - r_ij * 0.5) * (1.0 - min(1.0, abs(d - depth) / depth_contrib));\n                    if (weight_ij > 0.0) {\n                        averageColor += weight_ij * texture2D(colorTexture, uv);\n                        averageDepth += weight_ij * d;\n                        total_weight += weight_ij;\n                    }\n                }\n            }\n        }\n\n        if (total_weight > 0.0) {\n            gl_FragColor = averageColor / total_weight;\n            gl_FragDepthEXT = averageDepth / total_weight;\n        } else {\n            gl_FragColor.a = 0.0;\n            discard;\n        }\n    }\n}\n";

var _InpaintingFS2 = _interopRequireDefault(_InpaintingFS);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var RT = {
    FULL_RES_0: 0,
    FULL_RES_1: 1,
    EDL_VALUES: 2
};

function PointCloudRenderer(view) {
    this.scene = new THREE.Scene();

    // create 1 big triangle covering the screen
    var geom = new THREE.BufferGeometry();

    geom.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, -3, 2, 0, -3, 0, 2, -3], 3));
    geom.addAttribute('uv', new THREE.Float32BufferAttribute([0, 0, 2, 0, 0, 2], 2));
    this.mesh = new THREE.Mesh(geom, null);
    // this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
    this.mesh.frustumCulled = false;
    this.scene.add(this.mesh);

    // our camera
    this.camera = new THREE.OrthographicCamera(0, 1, 1, 0, 0, 10);

    this.classic = {
        passes: [undefined],
        setup: function setup() {
            return { material: undefined };
        }
    };

    // E(ye)D(ome)L(ighting) setup
    // References:
    //    - https://tel.archives-ouvertes.fr/tel-00438464/document
    //    - Potree (https://github.com/potree/potree/)
    this.edl = {
        passes: [
        // EDL 1st pass material
        // This pass is writing a single value per pixel, describing the depth
        // difference between one pixel and its neighbours.
        new THREE.ShaderMaterial({
            uniforms: {
                depthTexture: { value: null },
                resolution: { value: new THREE.Vector2(256, 256) },
                cameraNear: { value: 0.01 },
                cameraFar: { value: 100 },
                radius: { value: 0 },
                strength: { value: 0 },
                directions: { value: 0 },
                n: { value: 0 },
                opacity: { value: 1.0 }
            },
            vertexShader: _BasicVS2.default,
            fragmentShader: _EDLPassOneFS2.default
        }),
        // EDL 2nd pass material
        // This pass combines the EDL value computed in pass 1 with pixels
        // colors from a normal rendering to compose the final pixel color
        new THREE.ShaderMaterial({
            uniforms: {
                depthTexture: { value: null },
                textureColor: { value: null },
                textureEDL: { value: null },
                opacity: { value: 1.0 }
            },
            vertexShader: _BasicVS2.default,
            fragmentShader: _EDLPassTwoFS2.default,
            extensions: { fragDepth: true }
        })],
        // EDL tuning
        parameters: {
            enabled: true,
            // distance to neighbours pixels
            radius: 3.0,
            // edl value coefficient
            strength: 0.35,
            // directions count where neighbours are taken
            directions: 8,
            // how many neighbours per direction
            n: 1
        },
        setup: function setup(renderer, input, passIdx) {
            var m = this.passes[passIdx];
            if (passIdx == 0) {
                m.uniforms.depthTexture.value = input.depthTexture;
                m.uniforms.resolution.value.set(input.width, input.height);
                m.uniforms.cameraNear.value = renderer.view.camera.camera3D.near;
                m.uniforms.cameraFar.value = renderer.view.camera.camera3D.far;
                m.uniforms.radius.value = this.parameters.radius;
                m.uniforms.strength.value = this.parameters.strength;
                m.uniforms.directions.value = this.parameters.directions;
                m.uniforms.n.value = this.parameters.n;

                return { material: m, output: renderer.renderTargets[RT.EDL_VALUES] };
            } else {
                m.uniforms.textureColor.value = input.texture;
                m.uniforms.textureEDL.value = renderer.renderTargets[RT.EDL_VALUES].texture;
                m.uniforms.depthTexture.value = input.depthTexture;

                return { material: m };
            }
        }
    };

    // Screen-space occlusion
    // References: http://www.crs4.it/vic/data/papers/vast2011-pbr.pdf
    this.occlusion = {
        passes: [
        // EDL 1st pass material
        // This pass is writing a single value per pixel, describing the depth
        // difference between one pixel and its neighbours.
        new THREE.ShaderMaterial({
            uniforms: {
                depthTexture: { value: null },
                colorTexture: { value: null },
                m43: { value: 0 },
                m33: { value: 0 },
                resolution: { value: new THREE.Vector2(256, 256) },
                invPersMatrix: { value: new THREE.Matrix4() },
                threshold: { value: 0 },
                showRemoved: { value: false },
                clearColor: { value: new THREE.Color() },
                opacity: { value: 1.0 }
            },
            vertexShader: _BasicVS2.default,
            fragmentShader: _OcclusionFS2.default,
            extensions: { fragDepth: true }
        })],
        // EDL tuning
        parameters: {
            enabled: true,
            // pixel suppression threshold
            threshold: 0.9,
            // debug feature to colorize removed pixels
            showRemoved: false
        },
        setup: function setup(renderer, input) {
            var m = this.passes[0];
            var n = renderer.view.camera.camera3D.near;
            var f = renderer.view.camera.camera3D.far;

            var mat = new THREE.Matrix4();
            mat.getInverse(renderer.view.camera.camera3D.projectionMatrix);

            m.uniforms.colorTexture.value = input.texture;
            m.uniforms.depthTexture.value = input.depthTexture;
            m.uniforms.resolution.value.set(input.width, input.height);
            m.uniforms.m43.value = -(2 * f * n) / (f - n);
            m.uniforms.m33.value = -(f + n) / (f - n);
            m.uniforms.threshold.value = this.parameters.threshold;
            m.uniforms.showRemoved.value = this.parameters.showRemoved;
            m.uniforms.invPersMatrix.value.getInverse(renderer.view.camera.camera3D.projectionMatrix);
            m.uniforms.clearColor.value.copy(renderer.view.mainLoop.gfxEngine.renderer.getClearColor());

            return { material: m };
        }
    };

    // Screen-space filling
    // References: http://www.crs4.it/vic/data/papers/vast2011-pbr.pdf
    this.inpainting = {
        passes: [
        // EDL 1st pass material
        // This pass is writing a single value per pixel, describing the depth
        // difference between one pixel and its neighbours.
        new THREE.ShaderMaterial({
            uniforms: {
                depthTexture: { value: null },
                colorTexture: { value: null },
                resolution: { value: new THREE.Vector2(256, 256) },
                depth_contrib: { value: 0.5 },
                opacity: { value: 1.0 }
            },
            vertexShader: _BasicVS2.default,
            fragmentShader: _InpaintingFS2.default,
            extensions: { fragDepth: true }
        })],
        // EDL tuning
        parameters: {
            enabled: true,
            // how many fill step should be performed
            fill_steps: 2,
            // depth contribution to the final color (?)
            depth_contrib: 0.5
        },
        setup: function setup(renderer, input) {
            var m = this.passes[0];

            m.uniforms.colorTexture.value = input.texture;
            m.uniforms.depthTexture.value = input.depthTexture;
            m.uniforms.resolution.value.set(input.width, input.height);
            m.uniforms.depth_contrib.value = this.parameters.depth_contrib;

            return { material: m };
        }
    };

    this.renderTargets = _createRenderTargets(view);

    this.view = view;
    view.addFrameRequester(this);
}

PointCloudRenderer.prototype.update = function () {
    if (this.view.camera.width != this.renderTargets[RT.FULL_RES_0].width || this.view.camera.width != this.renderTargets[RT.FULL_RES_0].height) {
        // release old render targets
        this.renderTargets.forEach(function (rt) {
            return rt.dispose();
        });
        // build new ones
        this.renderTargets = _createRenderTargets(this.view);
    }
};

PointCloudRenderer.prototype.renderView = function (view) {
    var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;

    var g = view.mainLoop.gfxEngine;
    var r = g.renderer;

    var stages = [];

    stages.push(this.classic);

    if (this.occlusion.parameters.enabled) {
        stages.push(this.occlusion);
    }
    if (this.inpainting.parameters.enabled) {
        for (var i = 0; i < this.inpainting.parameters.fill_steps; i++) {
            stages.push(this.inpainting);
        }
    }
    if (this.edl.parameters.enabled) {
        stages.push(this.edl);
    }

    var oldClearAlpha = r.getClearAlpha();
    r.setClearAlpha(0.0);

    var previousStageOutput = RT.FULL_RES_0;
    for (var _i = 0; _i < stages.length; _i++) {
        var stage = stages[_i];

        // ping-pong between FULL_RES_0 and FULL_RES_1, unless overriden by stage
        var stageOutput = (previousStageOutput + 1) % 2;
        for (var j = 0; j < stage.passes.length; j++) {
            // prepare stage
            // eslint-disable-next-line prefer-const
            var _stage$setup = stage.setup(this, this.renderTargets[previousStageOutput], j),
                material = _stage$setup.material,
                output = _stage$setup.output;

            // if last stage -> override output (draw to screen)


            if (_i == stages.length - 1 && j == stage.passes.length - 1) {
                output = null;
            } else if (!output) {
                output = this.renderTargets[stageOutput];
            }

            // render stage
            r.setRenderTarget(output);
            if (output) {
                r.clearTarget(output);
            }
            r.setViewport(0, 0, output ? output.width : view.camera.width, output ? output.height : view.camera.height);

            if (material) {
                // postprocessing scene
                this.mesh.material = material;
                if (output) {
                    this.mesh.material.transparent = false;
                    this.mesh.material.opacity = 1.0;
                } else {
                    this.mesh.material.transparent = true;
                    this.mesh.material.uniforms.opacity.value = opacity;
                }
                r.render(this.scene, this.camera, output);
            } else {
                r.render(view.scene, view.camera.camera3D, output);
            }
        }
        previousStageOutput = stageOutput;
    }

    r.setClearAlpha(oldClearAlpha);
};

function _createRenderTargets(view) {
    var renderTargets = [];
    renderTargets.push(new THREE.WebGLRenderTarget(view.camera.width, view.camera.height));
    renderTargets.push(new THREE.WebGLRenderTarget(view.camera.width, view.camera.height));
    renderTargets.push(new THREE.WebGLRenderTarget(view.camera.width, view.camera.height));

    renderTargets[RT.FULL_RES_0].texture.minFilter = THREE.LinearFilter;
    renderTargets[RT.FULL_RES_0].texture.generateMipmaps = false;
    renderTargets[RT.FULL_RES_0].depthBuffer = true;
    renderTargets[RT.FULL_RES_0].texture.format = THREE.RGBAFormat;
    renderTargets[RT.FULL_RES_0].texture.minFilter = THREE.NearestFilter;
    renderTargets[RT.FULL_RES_0].texture.magFilter = THREE.NearestFilter;
    renderTargets[RT.FULL_RES_0].depthTexture = new THREE.DepthTexture();
    renderTargets[RT.FULL_RES_0].depthTexture.type = THREE.UnsignedShortType;

    renderTargets[RT.FULL_RES_1].texture.minFilter = THREE.LinearFilter;
    renderTargets[RT.FULL_RES_1].texture.generateMipmaps = false;
    renderTargets[RT.FULL_RES_1].depthBuffer = true;
    renderTargets[RT.FULL_RES_1].texture.format = THREE.RGBAFormat;
    renderTargets[RT.FULL_RES_1].texture.minFilter = THREE.NearestFilter;
    renderTargets[RT.FULL_RES_1].texture.magFilter = THREE.NearestFilter;
    renderTargets[RT.FULL_RES_1].depthTexture = new THREE.DepthTexture();
    renderTargets[RT.FULL_RES_1].depthTexture.type = THREE.UnsignedShortType;

    renderTargets[RT.EDL_VALUES] = new THREE.WebGLRenderTarget(view.camera.width, view.camera.height);
    renderTargets[RT.EDL_VALUES].texture.generateMipmaps = false;
    renderTargets[RT.EDL_VALUES].depthBuffer = false;
    renderTargets[RT.EDL_VALUES].texture.format = THREE.RGBAFormat;
    renderTargets[RT.EDL_VALUES].texture.minFilter = THREE.NearestFilter;
    renderTargets[RT.EDL_VALUES].texture.magFilter = THREE.NearestFilter;

    return renderTargets;
}

exports.default = PointCloudRenderer;
//# sourceMappingURL=PointCloudRenderer.js.map