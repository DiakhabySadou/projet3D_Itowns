{"version":3,"sources":["../../../src/Renderer/ThreeExtended/Feature2Mesh.js"],"names":["THREE","getAltitude","options","properties","altitude","getExtrude","extrude","randomColor","Color","setHex","Math","random","getColor","color","fillColorArray","colors","offset","length","r","g","b","i","coordinatesToVertices","contour","target","coordinate","vec","xyz","normal","geodesicNormal","add","clone","multiplyScalar","toArray","extractFeature","coordinates","id","featureVertices","slice","count","property","addFaces","indices","push","coordinateToPoints","vertices","Float32Array","Uint8Array","geometry","BufferGeometry","addAttribute","BufferAttribute","Points","coordinateToLines","line","setIndex","Uint16Array","LineSegments","coordinateToPolygon","altitudeBottom","verticesTopFace","triangles","indice","Mesh","coordinateToPolygonExtruded","offset2","nbVertices","extrudeAmount","result","coordinatesToMesh","mesh","type","material","vertexColors","VertexColors","featureToThree","feature","featureCollectionToThree","featureCollection","group","Group","geometries","features","convert"],"mappings":"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","file":"Feature2Mesh.js","sourcesContent":["import * as THREE from 'three';\nimport Earcut from 'earcut';\n\nfunction getAltitude(options, properties) {\n    if (options.altitude) {\n        if (typeof options.altitude === 'function') {\n            return options.altitude(properties);\n        } else {\n            return options.altitude;\n        }\n    }\n    return 0;\n}\n\nfunction getExtrude(options, properties) {\n    if (options.extrude) {\n        if (typeof options.extrude === 'function') {\n            return options.extrude(properties);\n        } else {\n            return options.extrude;\n        }\n    }\n    return 0;\n}\n\nfunction randomColor() {\n    const randomColor = new THREE.Color();\n    randomColor.setHex(Math.random() * 0xffffff);\n    return randomColor;\n}\n\nfunction getColor(options, properties) {\n    if (options.color) {\n        if (typeof options.color === 'function') {\n            return options.color(properties);\n        } else {\n            return options.color;\n        }\n    }\n    return randomColor();\n}\n\nfunction fillColorArray(colors, offset, length, r, g, b) {\n    const len = offset + length;\n    for (let i = offset; i < len; ++i) {\n        colors[3 * i] = r;\n        colors[3 * i + 1] = g;\n        colors[3 * i + 2] = b;\n    }\n}\n\n/*\n * Convert coordinates to vertices positionned at a given altitude\n *\n * @param  {Coordinate[]} contour - Coordinates of a feature\n * @param  {number} altitude - Altitude of the feature\n * @return {Vector3[]} vertices\n */\nfunction coordinatesToVertices(contour, altitude, target, offset) {\n    // loop over contour coodinates\n    for (const coordinate of contour) {\n        // convert coordinate to position\n        const vec = coordinate.xyz();\n        // get the normal vector.\n        const normal = coordinate.geodesicNormal;\n        // move the vertex following the normal, to put the point on the good altitude\n        vec.add(normal.clone().multiplyScalar(altitude));\n        // fill the vertices array at the offset position\n        vec.toArray(target, offset);\n        // increment the offset\n        offset += 3;\n    }\n}\n\n/*\n * Helper function to extract, for a given feature id, the feature contour coordinates, and its properties.\n *\n * param  {structure with coordinate[] and featureVertices[]} coordinates - representation of the features\n * param  {properties[]} properties - properties of the features\n * param  {number} id - id of the feature\n * return {Coordinate[], propertie[] } {contour, properties}\n */\nfunction extractFeature(coordinates, properties, id) {\n    const featureVertices = coordinates.featureVertices[id];\n    const contour = coordinates.coordinates.slice(featureVertices.offset, featureVertices.offset + featureVertices.count);\n    const property = properties[id].properties;\n    return { contour, property };\n}\n\n/*\n * Add indices for the side faces.\n * We loop over the contour and create a side face made of two triangles.\n *\n * For a contour made of (n) coordinates, there are (n*2) vertices.\n * The (n) first vertices are on the roof, the (n) other vertices are on the floor.\n *\n * If index (i) is on the roof, index (i+length) is on the floor.\n *\n * @param {number[]} indices - Indices of vertices\n * @param {number} length - length of the contour of the feature\n * @param {number} offset - index of the first vertice of this feature\n */\nfunction addFaces(indices, length, offset) {\n    // loop over contour length, and for each point of the contour,\n    // add indices to make two triangle, that make the side face\n    for (let i = offset; i < offset + length - 1; ++i) {\n        // first triangle indices\n        indices.push(i);\n        indices.push(i + length);\n        indices.push(i + 1);\n        // second triangle indices\n        indices.push(i + 1);\n        indices.push(i + length);\n        indices.push(i + length + 1);\n    }\n}\n\nfunction coordinateToPoints(coordinates, properties, options) {\n    const vertices = new Float32Array(3 * coordinates.coordinates.length);\n    const colors = new Uint8Array(3 * coordinates.coordinates.length);\n    const geometry = new THREE.BufferGeometry();\n    let offset = 0;\n\n    /* eslint-disable guard-for-in */\n    for (const id in coordinates.featureVertices) {\n        const { contour, property } = extractFeature(coordinates, properties, id);\n        // get altitude from properties\n        const altitude = getAltitude(options, property);\n        coordinatesToVertices(contour, altitude, vertices, offset * 3);\n\n        // assign color to each point\n        const color = getColor(options, property);\n        fillColorArray(colors, offset, contour.length, color.r * 255, color.g * 255, color.b * 255);\n\n        // increment offset\n        offset += contour.length;\n    }\n    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n    geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3, true));\n    return new THREE.Points(geometry);\n}\n\nfunction coordinateToLines(coordinates, properties, options) {\n    const indices = [];\n    const vertices = new Float32Array(3 * coordinates.coordinates.length);\n    const colors = new Uint8Array(3 * coordinates.coordinates.length);\n    const geometry = new THREE.BufferGeometry();\n    let offset = 0;\n\n    /* eslint-disable-next-line */\n    for (const id in coordinates.featureVertices) {\n        const { contour, property } = extractFeature(coordinates, properties, id);\n        // get altitude from properties\n        const altitude = getAltitude(options, property);\n        coordinatesToVertices(contour, altitude, vertices, offset * 3);\n\n        // set indices\n        const line = coordinates.featureVertices[id];\n        // TODO optimize indices lines\n        // is the same array each time\n        for (let i = line.offset; i < line.offset + line.count - 1; ++i) {\n            indices.push(i);\n            indices.push(i + 1);\n        }\n\n        // assign color to each point\n        const color = getColor(options, property);\n        fillColorArray(colors, offset, contour.length, color.r * 255, color.g * 255, color.b * 255);\n\n        // increment offset\n        offset += contour.length;\n    }\n\n    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n    geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3, true));\n    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));\n    return new THREE.LineSegments(geometry);\n}\n\nfunction coordinateToPolygon(coordinates, properties, options) {\n    const indices = [];\n    const vertices = new Float32Array(3 * coordinates.coordinates.length);\n    const colors = new Uint8Array(3 * coordinates.coordinates.length);\n    const geometry = new THREE.BufferGeometry();\n    let offset = 0;\n    /* eslint-disable-next-line */\n    for (const id in coordinates.featureVertices) {\n        // extract contour coodinates and properties of one feature\n        const { contour, property } = extractFeature(coordinates, properties, id);\n        // get altitude and extrude amount from properties\n        const altitudeBottom = getAltitude(options, property);\n        const altitudeTopFace = altitudeBottom;\n        // add vertices of the top face\n        coordinatesToVertices(contour, altitudeTopFace, vertices, offset * 3);\n        const verticesTopFace = vertices.slice(offset * 3, offset * 3 + contour.length * 3);\n        // triangulate the top face\n        const triangles = Earcut(verticesTopFace, null, 3);\n        for (const indice of triangles) {\n            indices.push(offset + indice);\n        }\n        // assign color to each point\n        const color = getColor(options, property);\n        fillColorArray(colors, offset, contour.length, color.r * 255, color.g * 255, color.b * 255);\n        // increment offset\n        offset += contour.length;\n    }\n\n    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n    geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3, true));\n    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));\n    return new THREE.Mesh(geometry);\n}\n\nfunction coordinateToPolygonExtruded(coordinates, properties, options) {\n    const indices = [];\n    const vertices = new Float32Array(2 * 3 * coordinates.coordinates.length);\n    const colors = new Uint8Array(3 * 2 * coordinates.coordinates.length);\n    const geometry = new THREE.BufferGeometry();\n    let offset = 0;\n    let offset2 = 0;\n    let nbVertices = 0;\n\n    /* eslint-disable-next-line */\n    for (const id in coordinates.featureVertices) {\n        // extract contour coodinates and properties of one feature\n        const { contour, property } = extractFeature(coordinates, properties, id);\n        // get altitude and extrude amount from properties\n        const altitudeBottom = getAltitude(options, property);\n        const extrudeAmount = getExtrude(options, property);\n        // altitudeTopFace is the altitude of the visible top face.\n        const altitudeTopFace = altitudeBottom + extrudeAmount;\n        // add vertices of the top face\n        coordinatesToVertices(contour, altitudeTopFace, vertices, offset2);\n        // triangulate the top face\n        nbVertices = contour.length * 3;\n        const verticesTopFace = vertices.slice(offset2, offset2 + nbVertices);\n        const triangles = Earcut(verticesTopFace, null, 3);\n        for (const indice of triangles) {\n            indices.push(offset + indice);\n        }\n        offset2 += nbVertices;\n        // add vertices of the bottom face\n        coordinatesToVertices(contour, altitudeBottom, vertices, offset2);\n        offset2 += nbVertices;\n        // add indices to make the side faces\n        addFaces(indices, contour.length, offset);\n        // assign color to each point\n        const color = getColor(options, property);\n        fillColorArray(colors, offset, contour.length, color.r * 255, color.g * 255, color.b * 255);\n        offset += contour.length;\n        fillColorArray(colors, offset, contour.length, color.r * 155, color.g * 155, color.b * 155);\n        offset += contour.length;\n    }\n    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n    geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3, true));\n    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(indices), 1));\n    const result = new THREE.Mesh(geometry);\n\n    return result;\n}\n\n/*\n * Convert all feature coordinates in one mesh.\n *\n * Read the altitude of each feature in the properties of the feature, using the function given in the param style : style.altitude(properties).\n * For polygon, read extrude amout using the function given in the param style.extrude(properties).\n *\n * param  {structure with coordinate[] and featureVertices[]} coordinates - representation of all the features\n * param  {properties[]} properties - properties of all the features\n * param  {callbacks} callbacks defines functions to read altitude and extrude amout from feature properties\n * return {THREE.Mesh} mesh\n */\nfunction coordinatesToMesh(coordinates, properties, options) {\n    if (!coordinates) {\n        return;\n    }\n    var mesh;\n    switch (coordinates.type) {\n        case 'point': {\n            mesh = coordinateToPoints(coordinates, properties, options);\n            break;\n        }\n        case 'linestring': {\n            mesh = coordinateToLines(coordinates, properties, options);\n            break;\n        }\n        case 'polygon': {\n            if (options.extrude) {\n                mesh = coordinateToPolygonExtruded(coordinates, properties, options);\n            }\n            else {\n                mesh = coordinateToPolygon(coordinates, properties, options);\n            }\n            break;\n        }\n        default:\n    }\n\n    // set mesh material\n    mesh.material.vertexColors = THREE.VertexColors;\n    mesh.material.color = new THREE.Color(0xffffff);\n    return mesh;\n}\n\nfunction featureToThree(feature, options) {\n    const mesh = coordinatesToMesh(feature.geometry, feature.properties, options);\n    mesh.properties = feature.properties;\n    return mesh;\n}\n\nfunction featureCollectionToThree(featureCollection, options) {\n    const group = new THREE.Group();\n    for (const geometry of featureCollection.geometries) {\n        const properties = featureCollection.features;\n        group.add(coordinatesToMesh(geometry, properties, options));\n    }\n    group.features = featureCollection.features;\n    return group;\n}\n\nexport default {\n\n    convert(options = {}) {\n        return function _convert(feature) {\n            if (!feature) return;\n            if (feature.geometries) {\n                return featureCollectionToThree(feature, options);\n            } else {\n                return featureToThree(feature, options);\n            }\n        };\n    },\n};\n"]}