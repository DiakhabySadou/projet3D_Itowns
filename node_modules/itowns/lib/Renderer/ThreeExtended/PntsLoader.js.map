{"version":3,"sources":["../../../src/Renderer/ThreeExtended/PntsLoader.js"],"names":["THREE","parse","buffer","textDecoder","Error","view","DataView","byteOffset","pntsHeader","batchTable","point","magic","decode","Uint8Array","version","getUint32","Uint32Array","BYTES_PER_ELEMENT","byteLength","FTJSONLength","FTBinaryLength","BTJSONLength","BTBinaryLength","parseFeatureBinary","sizeBegin","slice","pnts","array","geometry","BufferGeometry","material","PointsMaterial","size","vertexColors","VertexColors","sizeAttenuation","subArrayJson","parseJSON","JSON","lengthFeature","POINTS_LENGTH","POSITION","byteOffsetPos","length","positionArray","Float32Array","addAttribute","BufferAttribute","RGB","byteOffsetCol","colorArray","POSITION_QUANTIZED","RGBA","RGB565","NORMAL","NORMAL_OCT16P","BATCH_ID","points","Points","realPointCount","RTC_CENTER","position","fromArray"],"mappings":"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","file":"PntsLoader.js","sourcesContent":["import * as THREE from 'three';\nimport BT from './BatchTable';\n\nexport default {\n    parse: function parse(buffer, textDecoder) {\n        if (!buffer) {\n            throw new Error('No array buffer provided.');\n        }\n        const view = new DataView(buffer);\n\n        let byteOffset = 0;\n        const pntsHeader = {};\n        let batchTable = {};\n        let point = {};\n\n        // Magic type is unsigned char [4]\n        pntsHeader.magic = textDecoder.decode(new Uint8Array(buffer, byteOffset, 4));\n        byteOffset += 4;\n\n        if (pntsHeader.magic) {\n            // Version, byteLength, batchTableJSONByteLength, batchTableBinaryByteLength and batchTable types are uint32\n            pntsHeader.version = view.getUint32(byteOffset, true);\n            byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n\n            pntsHeader.byteLength = view.getUint32(byteOffset, true);\n            byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n\n            pntsHeader.FTJSONLength = view.getUint32(byteOffset, true);\n            byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n\n            pntsHeader.FTBinaryLength = view.getUint32(byteOffset, true);\n            byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n\n            pntsHeader.BTJSONLength = view.getUint32(byteOffset, true);\n            byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n\n            pntsHeader.BTBinaryLength = view.getUint32(byteOffset, true);\n            byteOffset += Uint32Array.BYTES_PER_ELEMENT;\n\n            // binary table\n            if (pntsHeader.FTBinaryLength > 0) {\n                point = parseFeatureBinary(buffer, byteOffset, pntsHeader.FTJSONLength, textDecoder);\n            }\n\n            // batch table\n            if (pntsHeader.BTJSONLength > 0) {\n                const sizeBegin = 28 + pntsHeader.FTJSONLength + pntsHeader.FTBinaryLength;\n                batchTable = BT.parse(\n                    buffer.slice(sizeBegin, pntsHeader.BTJSONLength + sizeBegin),\n                    textDecoder);\n            }\n\n            const pnts = { point, batchTable };\n            return pnts;\n        } else {\n            throw new Error('Invalid pnts file.');\n        }\n    },\n};\n\nfunction parseFeatureBinary(array, byteOffset, FTJSONLength, textDecoder) {\n    // Init geometry\n    const geometry = new THREE.BufferGeometry();\n    const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: THREE.VertexColors, sizeAttenuation: true });\n\n    // init Array feature binary\n    const subArrayJson = textDecoder.decode(new Uint8Array(array, byteOffset, FTJSONLength));\n    const parseJSON = JSON.parse(subArrayJson);\n    let lengthFeature;\n    if (parseJSON.POINTS_LENGTH) {\n        lengthFeature = parseJSON.POINTS_LENGTH;\n    }\n    if (parseJSON.POSITION) {\n        const byteOffsetPos = (parseJSON.POSITION.byteOffset + subArrayJson.length + byteOffset);\n        const positionArray = new Float32Array(array, byteOffsetPos, lengthFeature * 3);\n        geometry.addAttribute('position', new THREE.BufferAttribute(positionArray, 3));\n    }\n    if (parseJSON.RGB) {\n        const byteOffsetCol = parseJSON.RGB.byteOffset + subArrayJson.length + byteOffset;\n        const colorArray = new Uint8Array(array, byteOffsetCol, lengthFeature * 3);\n        geometry.addAttribute('color', new THREE.BufferAttribute(colorArray, 3, true));\n    }\n    if (parseJSON.POSITION_QUANTIZED) {\n        throw new Error('For pnts loader, POSITION_QUANTIZED: not yet managed');\n    }\n    if (parseJSON.RGBA) {\n        throw new Error('For pnts loader, RGBA: not yet managed');\n    }\n    if (parseJSON.RGB565) {\n        throw new Error('For pnts loader, RGB565: not yet managed');\n    }\n    if (parseJSON.NORMAL) {\n        throw new Error('For pnts loader, NORMAL: not yet managed');\n    }\n    if (parseJSON.NORMAL_OCT16P) {\n        throw new Error('For pnts loader, NORMAL_OCT16P: not yet managed');\n    }\n    if (parseJSON.BATCH_ID) {\n        throw new Error('For pnts loader, BATCH_ID: not yet managed');\n    }\n    // creation points with geometry and material\n    const points = new THREE.Points(geometry, material);\n    points.realPointCount = lengthFeature;\n\n    // Add RTC feature\n    if (parseJSON.RTC_CENTER) {\n        points.position.fromArray(parseJSON.RTC_CENTER);\n    }\n\n    return points;\n}\n"]}