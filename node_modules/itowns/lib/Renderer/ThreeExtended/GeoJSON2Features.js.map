{"version":3,"sources":["../../../src/Renderer/ThreeExtended/GeoJSON2Features.js"],"names":["readCRS","json","crs","type","toLowerCase","properties","code","epsgIdx","name","indexOf","codeStart","substr","Error","readCoordinates","crsIn","crsOut","coordinates","extent","out","pair","coords","push","as","expandByPoint","length","GeometryToCoordinates","point","coordsIn","filteringExtent","options","buildExtent","Infinity","undefined","filter","isPointInside","c","polygon","lineString","merge","result","offset","geoms","geom","clone","featureVertices","concat","union","featureIndex","count","multiLineString","line","l","multiPolygon","p","readGeometry","readFeature","feature","geometry","key","concatGeometries","idx","geometries","forEach","f","index","_idx","_meshIdx","g","map","readFeatureCollection","collec","features","points","lines","polygons","parse"],"mappings":"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","file":"GeoJSON2Features.js","sourcesContent":["/**\n * Generated On: 2016-09-28\n * Class: FeatureToolBox\n * Description:\n */\nimport Coordinates from '../../Core/Geographic/Coordinates';\nimport Extent from '../../Core/Geographic/Extent';\n\nfunction readCRS(json) {\n    if (json.crs) {\n        if (json.crs.type.toLowerCase() == 'epsg') {\n            return `EPSG:${json.crs.properties.code}`;\n        } else if (json.crs.type.toLowerCase() == 'name') {\n            const epsgIdx = json.crs.properties.name.toLowerCase().indexOf('epsg:');\n            if (epsgIdx >= 0) {\n                // authority:version:code => EPSG:[...]:code\n                const codeStart = json.crs.properties.name.indexOf(':', epsgIdx + 5);\n                if (codeStart > 0) {\n                    return `EPSG:${json.crs.properties.name.substr(codeStart + 1)}`;\n                }\n            }\n        }\n        throw new Error(`Unsupported CRS type '${json.crs}'`);\n    }\n    // assume default crs\n    return 'EPSG:4326';\n}\n\nfunction readCoordinates(crsIn, crsOut, coordinates, extent) {\n    // coordinates is a list of pair [[x1, y1], [x2, y2], ..., [xn, yn]]\n    const out = [];\n    for (const pair of coordinates) {\n        // TODO: 1 is a default z value, makes this configurable\n        const coords = new Coordinates(crsIn, pair[0], pair[1], 1);\n        if (crsIn === crsOut) {\n            out.push(coords);\n        } else {\n            out.push(coords.as(crsOut));\n        }\n        // expand extent if present\n        if (extent) {\n            extent.expandByPoint(out[out.length - 1]);\n        }\n    }\n    return out;\n}\n\n// Helper struct that returns an object { type: \"\", coordinates: [...], extent}:\n// - type is the geom type\n// - Coordinates is an array of Coordinate\n// - extent is optional, it's coordinates's extent\n// Multi-* geometry types are merged in one.\nconst GeometryToCoordinates = {\n    point(crsIn, crsOut, coordsIn, filteringExtent, options) {\n        const extent = options.buildExtent ? new Extent(crsOut, Infinity, -Infinity, Infinity, -Infinity) : undefined;\n        let coordinates = readCoordinates(crsIn, crsOut, coordsIn, extent);\n        if (filteringExtent) {\n            coordinates = coordinates.filter(c => filteringExtent.isPointInside(c));\n        }\n        return { type: 'point', coordinates, extent };\n    },\n    polygon(crsIn, crsOut, coordsIn, filteringExtent, options) {\n        const extent = options.buildExtent ? new Extent(crsOut, Infinity, -Infinity, Infinity, -Infinity) : undefined;\n        const coordinates = readCoordinates(crsIn, crsOut, coordsIn, extent);\n        if (filteringExtent && !filteringExtent.isPointInside(coordinates[0])) {\n            return;\n        }\n        return { type: 'polygon', coordinates, extent };\n    },\n    lineString(crsIn, crsOut, coordsIn, filteringExtent, options) {\n        const extent = options.buildExtent ? new Extent(crsOut, Infinity, -Infinity, Infinity, -Infinity) : undefined;\n        const coordinates = readCoordinates(crsIn, crsOut, coordsIn, extent);\n        if (filteringExtent && !filteringExtent.isPointInside(coordinates[0])) {\n            return;\n        }\n        return { type: 'linestring', coordinates, extent };\n    },\n    merge(...geoms) {\n        let result;\n        let offset = 0;\n        for (const geom of geoms) {\n            if (!geom) {\n                continue;\n            }\n            if (!result) {\n                result = geom;\n                // instance extent if present\n\n                if (geom.extent) {\n                    result.extent = geom.extent.clone();\n                }\n                result.featureVertices = {};\n            } else {\n                // merge coordinates\n                result.coordinates = result.coordinates.concat(geom.coordinates);\n                // union extent if present\n                if (geom.extent) {\n                    result.extent.union(geom.extent);\n                }\n            }\n            result.featureVertices[geom.featureIndex || 0] = { offset, count: geom.coordinates.length, extent: geom.extent };\n            offset = result.coordinates.length;\n        }\n        return result;\n    },\n    multiLineString(crsIn, crsOut, coordsIn, filteringExtent, options) {\n        let result;\n        for (const line of coordsIn) {\n            const l = this.lineString(crsIn, crsOut, line, filteringExtent, options);\n            if (!l) {\n                return;\n            }\n            // only test the first line\n            filteringExtent = undefined;\n            result = this.merge(result, l);\n        }\n        return result;\n    },\n    multiPolygon(crsIn, crsOut, coordsIn, filteringExtent, options) {\n        let result;\n        for (const polygon of coordsIn) {\n            const p = this.polygon(crsIn, crsOut, polygon[0], filteringExtent, options);\n            if (!p) {\n                return;\n            }\n            // only test the first poly\n            filteringExtent = undefined;\n            result = this.merge(result, p);\n        }\n        return result;\n    },\n};\n\nfunction readGeometry(crsIn, crsOut, json, filteringExtent, options) {\n    if (json.coordinates.length == 0) {\n        return;\n    }\n    switch (json.type.toLowerCase()) {\n        case 'point':\n            return GeometryToCoordinates.point(crsIn, crsOut, [json.coordinates], filteringExtent, options);\n        case 'multipoint':\n            return GeometryToCoordinates.point(crsIn, crsOut, json.coordinates, filteringExtent, options);\n        case 'linestring':\n            return GeometryToCoordinates.lineString(crsIn, crsOut, json.coordinates, filteringExtent, options);\n        case 'multilinestring':\n            return GeometryToCoordinates.multiLineString(crsIn, crsOut, json.coordinates, filteringExtent, options);\n        case 'polygon':\n            return GeometryToCoordinates.polygon(crsIn, crsOut, json.coordinates[0], filteringExtent, options);\n        case 'multipolygon':\n            return GeometryToCoordinates.multiPolygon(crsIn, crsOut, json.coordinates, filteringExtent, options);\n        case 'geometrycollection':\n        default:\n            throw new Error(`Unhandled geometry type ${json.type}`);\n    }\n}\n\nfunction readFeature(crsIn, crsOut, json, filteringExtent, options) {\n    if (options.filter && !options.filter(json.properties)) {\n        return;\n    }\n    const feature = {};\n    feature.geometry = readGeometry(crsIn, crsOut, json.geometry, filteringExtent, options);\n\n    if (!feature.geometry) {\n        return;\n    }\n    feature.properties = json.properties || {};\n    // copy other properties\n    for (const key of Object.keys(json)) {\n        if (['type', 'geometry', 'properties'].indexOf(key.toLowerCase()) < 0) {\n            feature.properties[key] = json[key];\n        }\n    }\n\n    return feature;\n}\n\nfunction concatGeometries(result, geometry) {\n    const idx = result.geometries.length;\n    geometry.forEach((f, index) => { f.properties._idx = index; f.properties._meshIdx = idx; });\n    const g = geometry.map(p => p.geometry);\n    const p = GeometryToCoordinates.merge(...g);\n    result.geometries.push(p);\n    if (p.extent) {\n        if (result.extent) {\n            result.extent.union(p.extent);\n        } else {\n            result.extent = p.extent.clone();\n        }\n    }\n}\n\nfunction readFeatureCollection(crsIn, crsOut, json, filteringExtent, options) {\n    const collec = [];\n\n    let featureIndex = 0;\n    for (const feature of json.features) {\n        const f = readFeature(crsIn, crsOut, feature, filteringExtent, options);\n        if (f) {\n            f.geometry.featureIndex = featureIndex;\n            collec.push(f);\n            featureIndex++;\n        }\n    }\n    if (collec.length) {\n        // sort by types\n        const geom = {\n            points: collec.filter(c => c.geometry.type === 'point'),\n            lines: collec.filter(c => c.geometry.type === 'linestring'),\n            polygons: collec.filter(c => c.geometry.type === 'polygon'),\n        };\n        const result = { geometries: [] };\n        if (geom.points.length) {\n            concatGeometries(result, geom.points);\n        }\n        if (geom.lines.length) {\n            concatGeometries(result, geom.lines);\n        }\n        if (geom.polygons.length) {\n            concatGeometries(result, geom.polygons);\n        }\n        // remember individual features properties\n        // eslint-disable-next-line arrow-body-style\n        result.features = collec.map((c) => { return { properties: c.properties }; });\n        if (result.geometries.length) {\n            return result;\n        }\n    }\n}\n\nexport default {\n    parse(crsOut, json, filteringExtent, options = {}) {\n        options.crsIn = options.crsIn || readCRS(json);\n        switch (json.type.toLowerCase()) {\n            case 'featurecollection':\n                return readFeatureCollection(options.crsIn, crsOut, json, filteringExtent, options);\n            case 'feature':\n                return readFeature(options.crsIn, crsOut, json, filteringExtent, options);\n            default:\n                throw new Error(`Unsupported GeoJSON type: '${json.type}`);\n        }\n    },\n};\n"]}