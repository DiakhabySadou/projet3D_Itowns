{"version":3,"sources":["../../../src/Renderer/ThreeExtended/PlanarControls.js"],"names":["THREE","keys","CTRL","SPACE","T","Y","mouseButtons","LEFTCLICK","MOUSE","LEFT","MIDDLECLICK","MIDDLE","RIGHTCLICK","RIGHT","STATE","NONE","DRAG","PAN","ROTATE","TRAVEL","PlanarControls","view","options","camera","camera3D","domElement","mainLoop","gfxEngine","renderer","rotateSpeed","maxPanSpeed","minPanSpeed","zoomTravelTime","zoomInFactor","zoomOutFactor","maxAltitude","groundLevel","autoTravelTimeMin","autoTravelTimeMax","autoTravelTimeDist","smartZoomHeightMin","smartZoomHeightMax","instantTravel","minZenithAngle","Math","PI","maxZenithAngle","focusOnMouseOver","focusOnMouseClick","handleCollision","minDistanceCollision","startPosition","position","clone","startQuaternion","quaternion","state","mousePosition","Vector2","lastMousePosition","deltaMousePosition","dragStart","Vector3","dragEnd","dragDelta","centerPoint","phi","travelEndPos","travelStartPos","travelStartRot","Quaternion","travelEndRot","travelAlpha","travelDuration","travelUseRotation","travelUseSmooth","_handlerOnKeyDown","onKeyDown","bind","_handlerOnMouseDown","onMouseDown","_handlerOnMouseUp","onMouseUp","_handlerOnMouseMove","onMouseMove","_handlerOnMouseWheel","onMouseWheel","addEventListener","focus","focusOnClick","onContextMenu","addFrameRequester","update","dt","updateLoopRestarted","adjustAltitudeToAvoidCollisionWithLayer","getLayers","layer","type","handleTravel","notifyChange","handleDragMovement","handleRotation","handlePanMovement","set","initiateDrag","copy","getWorldPointAtScreenXY","getWorldPointFromMathPlaneAtScreenXY","z","subVectors","add","initiatePan","vec","distToGround","clamp","panSpeed","lerp","x","localToWorld","newAltitude","y","initiateRotation","clientWidth","clientHeight","r","distanceTo","acos","quat","thetaDelta","phiDelta","offset","sub","setFromUnitVectors","up","applyQuaternion","setFromMatrixColumn","matrix","setFromAxisAngle","inverse","lookAt","initiateZoom","event","delta","wheelDelta","undefined","detail","pointUnderCursor","newPos","lerpVectors","initiateTravel","initiateSmartZoom","getPickingPositionFromDepth","dir","normalize","distanceToPoint","targetHeight","min","moveTarget","multiplyScalar","targetPos","travelTime","targetOrientation","useSmooth","updateMouseCursorType","normalizedDistance","angularDifference","dot","endTravel","alpha","smooth","slerp","goToTopView","topViewPos","targetQuat","goToStartView","vector","posXY","altitude","unproject","distance","updateMousePositionAndDelta","clientX","clientY","addInputListeners","removeInputListeners","removeEventListener","style","cursor","preventDefault","button","ctrlKey","keyCode","stopPropagation","value","pow"],"mappings":"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","file":"PlanarControls.js","sourcesContent":["/** Description: Camera controls adapted for a planar view, with animated movements\n* Left mouse button : \"drag\" the ground, translating the camera on the (xy) world plane.\n* Right mouse button : translate the camera on local x and world z axis (pan)\n* Ctrl + left mouse : rotate (orbit) around the camera's focus point.\n* Scroll wheel : zooms toward cursor position (animated).\n* Middle mouse button (wheel click) : 'smart zoom' at cursor location (animated).\n* Y : go to start view (animated)\n* T : go to top view (animated)\n* How to use : instanciate PlanarControls after camera setup (setPosition and lookAt)\n*/\n\nimport * as THREE from 'three';\n\n// event keycode\nconst keys = {\n    CTRL: 17,\n    SPACE: 32,\n    T: 84,\n    Y: 89,\n};\n\nconst mouseButtons = {\n    LEFTCLICK: THREE.MOUSE.LEFT,\n    MIDDLECLICK: THREE.MOUSE.MIDDLE,\n    RIGHTCLICK: THREE.MOUSE.RIGHT,\n};\n\n// control state\nconst STATE = {\n    NONE: -1,\n    DRAG: 0,\n    PAN: 1,\n    ROTATE: 2,\n    TRAVEL: 3,\n};\n\n/**\n* PlanarControls Constructor\n* Numerical values have been adjusted for the example provided in examples/planar.html\n* Most of them can be changed with the options parameter\n* @param {PlanarView} view : the itowns view (planar view)\n* @param {options} options : optional parameters.\n*/\nfunction PlanarControls(view, options = {}) {\n    this.view = view;\n    this.camera = view.camera.camera3D;\n    this.domElement = view.mainLoop.gfxEngine.renderer.domElement;\n\n    this.rotateSpeed = options.rotateSpeed || 2.0;\n\n    // minPanSpeed when close to the ground, maxPanSpeed when close to maxAltitude\n    this.maxPanSpeed = options.maxPanSpeed || 15;\n    this.minPanSpeed = options.minPanSpeed || 0.05;\n\n    // animation duration for the zoom\n    this.zoomTravelTime = options.zoomTravelTime || 0.2;\n\n    // zoom movement is equal to the distance to the zoom target, multiplied by zoomFactor\n    this.zoomInFactor = options.zoomInFactor || 0.25;\n    this.zoomOutFactor = options.zoomOutFactor || 0.4;\n\n    // pan movement is clamped between maxAltitude and groundLevel\n    this.maxAltitude = options.maxAltitude || 12000;\n\n    // approximate ground altitude value\n    this.groundLevel = options.groundLevel || 200;\n\n    // min and max duration in seconds, for animated travels with 'auto' parameter\n    this.autoTravelTimeMin = options.autoTravelTimeMin || 1.5;\n    this.autoTravelTimeMax = options.autoTravelTimeMax || 4;\n\n    // max travel duration is reached for this travel distance (empirical smoothing value)\n    this.autoTravelTimeDist = options.autoTravelTimeDist || 20000;\n\n    // after a smartZoom, camera height above ground will be between these two values\n    this.smartZoomHeightMin = options.smartZoomHeightMin || 75;\n    this.smartZoomHeightMax = options.smartZoomHeightMax || 500;\n\n    // if set to true, animated travels have 0 duration\n    this.instantTravel = options.instantTravel || false;\n\n    this.minZenithAngle = options.minZenithAngle || 0 * Math.PI / 180;\n\n    // should be less than 90 deg (90 = parallel to the ground)\n    this.maxZenithAngle = (options.maxZenithAngle || 82.5) * Math.PI / 180;\n\n    // focus policy options\n    this.focusOnMouseOver = options.focusOnMouseOver || true;\n    this.focusOnMouseClick = options.focusOnMouseClick || true;\n\n    // Set collision options\n    this.handleCollision = typeof (options.handleCollision) !== 'undefined' ? options.handleCollision : true;\n    this.minDistanceCollision = 30;\n\n    // starting camera position and orientation target are setup before instanciating PlanarControls\n    // using: view.camera.setPosition() and view.camera.lookAt()\n    // startPosition and startQuaternion are stored to be able to return to the start view\n    const startPosition = this.camera.position.clone();\n    const startQuaternion = this.camera.quaternion.clone();\n\n    // control state\n    this.state = STATE.NONE;\n\n    // mouse movement\n    const mousePosition = new THREE.Vector2();\n    const lastMousePosition = new THREE.Vector2();\n    const deltaMousePosition = new THREE.Vector2(0, 0);\n\n    // drag movement\n    const dragStart = new THREE.Vector3();\n    const dragEnd = new THREE.Vector3();\n    const dragDelta = new THREE.Vector3();\n\n    // camera focus point : ground point at screen center\n    const centerPoint = new THREE.Vector3(0, 0, 0);\n\n    // camera rotation\n    let phi = 0.0;\n\n    // animated travel\n    const travelEndPos = new THREE.Vector3();\n    const travelStartPos = new THREE.Vector3();\n    const travelStartRot = new THREE.Quaternion();\n    const travelEndRot = new THREE.Quaternion();\n    let travelAlpha = 0;\n    let travelDuration = 0;\n    let travelUseRotation = false;\n    let travelUseSmooth = false;\n\n    // eventListeners handlers\n    const _handlerOnKeyDown = onKeyDown.bind(this);\n    const _handlerOnMouseDown = onMouseDown.bind(this);\n    const _handlerOnMouseUp = onMouseUp.bind(this);\n    const _handlerOnMouseMove = onMouseMove.bind(this);\n    const _handlerOnMouseWheel = onMouseWheel.bind(this);\n\n    // focus policy\n    if (this.focusOnMouseOver) {\n        this.domElement.addEventListener('mouseover', () => this.domElement.focus());\n    }\n    if (this.focusOnClick) {\n        this.domElement.addEventListener('click', () => this.domElement.focus());\n    }\n\n    // prevent the default contextmenu from appearing when right-clicking\n    // this allows to use right-click for input without the menu appearing\n    this.domElement.addEventListener('contextmenu', onContextMenu.bind(this), false);\n\n    // add this PlanarControl instance to the view's framerequesters\n    // with this, PlanarControl.update() will be called each frame\n    this.view.addFrameRequester(this);\n\n    // Updates the view and camera if needed, and handles the animated travel\n    this.update = function update(dt, updateLoopRestarted) {\n        // We test if camera collide to geometry layer or too close to ground and ajust it's altitude in case\n        if (this.handleCollision) { // We check distance to the ground/surface geometry. (Could be another geometry layer)\n            this.view.camera.adjustAltitudeToAvoidCollisionWithLayer(this.view, view.getLayers(layer => layer.type === 'geometry')[0], this.minDistanceCollision);\n        }\n        // dt will not be relevant when we just started rendering, we consider a 1-frame move in this case\n        if (updateLoopRestarted) {\n            dt = 16;\n        }\n        if (this.state === STATE.TRAVEL) {\n            this.handleTravel(dt);\n            this.view.notifyChange(true);\n        }\n        if (this.state === STATE.DRAG) {\n            this.handleDragMovement();\n        }\n        if (this.state === STATE.ROTATE) {\n            this.handleRotation();\n        }\n        if (this.state === STATE.PAN) {\n            this.handlePanMovement();\n        }\n        deltaMousePosition.set(0, 0);\n    };\n\n    /**\n    * Initiate a drag movement (translation on xy plane)\n    * The movement value is derived from the actual world point under the mouse cursor\n    * This allows the user to 'grab' a world point and drag it to move (eg : google map)\n    */\n    this.initiateDrag = function initiateDrag() {\n        this.state = STATE.DRAG;\n\n        // the world point under mouse cursor when the drag movement is started\n        dragStart.copy(this.getWorldPointAtScreenXY(mousePosition));\n\n        // the difference between start and end cursor position\n        dragDelta.set(0, 0, 0);\n    };\n\n    /**\n    * Handle the drag movement (translation on xy plane) when user moves the mouse while in STATE.DRAG\n    * The drag movement is previously initiated by initiateDrag()\n    * Compute the drag value and update the camera controls.\n    * The movement value is derived from the actual world point under the mouse cursor\n    * This allows the user to 'grab' a world point and drag it to move (eg : google map)\n    */\n    this.handleDragMovement = function handleDragMovement() {\n        // the world point under the current mouse cursor position, at same altitude than dragStart\n        dragEnd.copy(this.getWorldPointFromMathPlaneAtScreenXY(mousePosition, dragStart.z));\n\n        // the difference between start and end cursor position\n        dragDelta.subVectors(dragStart, dragEnd);\n\n        this.camera.position.add(dragDelta);\n\n        dragDelta.set(0, 0, 0);\n    };\n\n    /**\n    * Initiate a pan movement (local translation on xz plane)\n    */\n    this.initiatePan = function initiatePan() {\n        this.state = STATE.PAN;\n    };\n\n    /**\n    * Handle the pan movement (translation on local x / world z plane) when user moves the mouse while in STATE.PAN\n    * The drag movement is previously initiated by initiatePan()\n    * Compute the pan value and update the camera controls.\n    */\n    this.handlePanMovement = (() => {\n        const vec = new THREE.Vector3();\n\n        return () => {\n            // normalized (betwwen 0 and 1) distance between groundLevel and maxAltitude\n            const distToGround = THREE.Math.clamp((this.camera.position.z - this.groundLevel) / this.maxAltitude, 0, 1);\n\n            // pan movement speed, adujsted according to altitude\n            const panSpeed = THREE.Math.lerp(this.minPanSpeed, this.maxPanSpeed, distToGround);\n\n            // lateral movement (local x axis)\n            vec.set(panSpeed * -1 * deltaMousePosition.x, 0, 0);\n            this.camera.position.copy(this.camera.localToWorld(vec));\n\n            // vertical movement (world z axis)\n            const newAltitude = this.camera.position.z + panSpeed * deltaMousePosition.y;\n\n            // check if altitude is valid\n            if (newAltitude < this.maxAltitude && newAltitude > this.groundLevel) {\n                this.camera.position.z = newAltitude;\n            }\n        };\n    })();\n\n    /**\n    * Initiate a rotate (orbit) movement\n    */\n    this.initiateRotation = function initiateRotation() {\n        this.state = STATE.ROTATE;\n\n        centerPoint.copy(this.getWorldPointAtScreenXY({ x: 0.5 * this.domElement.clientWidth, y: 0.5 * this.domElement.clientHeight }));\n\n        const r = this.camera.position.distanceTo(centerPoint);\n        phi = Math.acos((this.camera.position.z - centerPoint.z) / r);\n    };\n\n    /**\n    * Handle the rotate movement (orbit) when user moves the mouse while in STATE.ROTATE\n    * the movement is an orbit around 'centerPoint', the camera focus point (ground point at screen center)\n    * The rotate movement is previously initiated in initiateRotation()\n    * Compute the new position value and update the camera controls.\n    */\n    this.handleRotation = (() => {\n        const vec = new THREE.Vector3();\n        const quat = new THREE.Quaternion();\n\n        return () => {\n            // angle deltas\n            // deltaMousePosition is computed in onMouseMove / onMouseDown s\n            const thetaDelta = -this.rotateSpeed * deltaMousePosition.x / this.domElement.clientWidth;\n            const phiDelta = -this.rotateSpeed * deltaMousePosition.y / this.domElement.clientHeight;\n\n            // the vector from centerPoint (focus point) to camera position\n            const offset = this.camera.position.clone().sub(centerPoint);\n\n            if (thetaDelta !== 0 || phiDelta !== 0) {\n                if ((phi + phiDelta >= this.minZenithAngle)\n                && (phi + phiDelta <= this.maxZenithAngle)\n                && phiDelta !== 0) {\n                    // rotation around X (altitude)\n                    phi += phiDelta;\n\n                    vec.set(0, 0, 1);\n                    quat.setFromUnitVectors(this.camera.up, vec);\n                    offset.applyQuaternion(quat);\n\n                    vec.setFromMatrixColumn(this.camera.matrix, 0);\n                    quat.setFromAxisAngle(vec, phiDelta);\n                    offset.applyQuaternion(quat);\n\n                    vec.set(0, 0, 1);\n                    quat.setFromUnitVectors(this.camera.up, vec).inverse();\n                    offset.applyQuaternion(quat);\n                }\n                if (thetaDelta !== 0) {\n                    // rotation around Z (azimuth)\n                    vec.set(0, 0, 1);\n                    quat.setFromAxisAngle(vec, thetaDelta);\n                    offset.applyQuaternion(quat);\n                }\n            }\n\n            this.camera.position.copy(offset).add(centerPoint);\n\n            this.camera.lookAt(centerPoint);\n        };\n    })();\n\n    /**\n    * Triggers a Zoom animated movement (travel) toward / away from the world point under the mouse cursor\n    * The zoom intensity varies according to the distance between the camera and the point.\n    * The closer to the ground, the lower the intensity\n    * Orientation will not change (null parameter in the call to initiateTravel function)\n    * @param {event} event : the mouse wheel event.\n    */\n    this.initiateZoom = function initiateZoom(event) {\n        let delta;\n\n        // mousewheel delta\n        if (event.wheelDelta !== undefined) {\n            delta = event.wheelDelta;\n        } else if (event.detail !== undefined) {\n            delta = -event.detail;\n        }\n\n        const pointUnderCursor = this.getWorldPointAtScreenXY(mousePosition);\n        const newPos = new THREE.Vector3();\n\n        // Zoom IN\n        if (delta > 0) {\n            // target position\n            newPos.lerpVectors(this.camera.position, pointUnderCursor, this.zoomInFactor);\n            // initiate travel\n            this.initiateTravel(newPos, this.zoomTravelTime, null, false);\n        }\n        // Zoom OUT\n        else if (delta < 0 && this.camera.position.z < this.maxAltitude) {\n            // target position\n            newPos.lerpVectors(this.camera.position, pointUnderCursor, -1 * this.zoomOutFactor);\n            // initiate travel\n            this.initiateTravel(newPos, this.zoomTravelTime, null, false);\n        }\n    };\n\n    /**\n    * Triggers a 'smart zoom' animated movement (travel) toward the point under mouse cursor\n    * The camera will be smoothly moved and oriented close to the target, at a determined height and distance\n    */\n    this.initiateSmartZoom = function initiateSmartZoom() {\n        // point under mouse cursor\n        const pointUnderCursor = new THREE.Vector3();\n\n        // check if there is valid geometry under cursor\n        if (typeof this.view.getPickingPositionFromDepth(mousePosition) !== 'undefined') {\n            pointUnderCursor.copy(this.view.getPickingPositionFromDepth(mousePosition));\n        }\n        else {\n            return;\n        }\n\n        // direction of the movement, projected on xy plane and normalized\n        const dir = new THREE.Vector3();\n        dir.copy(pointUnderCursor).sub(this.camera.position);\n        dir.z = 0;\n        dir.normalize();\n\n        const distanceToPoint = this.camera.position.distanceTo(pointUnderCursor);\n\n        // camera height (altitude above ground) at the end of the travel, 5000 is an empirical smoothing distance\n        const targetHeight = THREE.Math.lerp(this.smartZoomHeightMin, this.smartZoomHeightMax, Math.min(distanceToPoint / 5000, 1));\n\n        // camera position at the end of the travel\n        const moveTarget = new THREE.Vector3();\n\n        moveTarget.copy(pointUnderCursor).add(dir.multiplyScalar(-targetHeight * 2));\n        moveTarget.z = pointUnderCursor.z + targetHeight;\n\n        // initiate the travel\n        this.initiateTravel(moveTarget, 'auto', pointUnderCursor, true);\n    };\n\n\n    /**\n    * Triggers an animated movement & rotation for the camera\n    * @param {THREE.Vector3} targetPos : the target position of the camera (reached at the end)\n    * @param {number} travelTime : set to 'auto', or set to a duration in seconds.\n    * If set to auto : travel time will be set to a duration between autoTravelTimeMin and autoTravelTimeMax\n    * according to the distance and the angular difference between start and finish.\n    * @param {(string|THREE.Vector3|THREE.Quaternion)} targetOrientation : define the target rotation of the camera\n    * if targetOrientation is a world point (Vector3) : the camera will lookAt() this point\n    * if targetOrientation is a quaternion : this quaternion will define the final camera orientation\n    * if targetOrientation is neither a quaternion nor a world point : the camera will keep its starting orientation\n    * @param {boolean} useSmooth : animation is smoothed using the 'smooth(value)' function (slower at start and finish)\n    */\n    this.initiateTravel = function initiateTravel(targetPos, travelTime, targetOrientation, useSmooth) {\n        this.state = STATE.TRAVEL;\n        this.view.notifyChange(true);\n        // the progress of the travel (animation alpha)\n        travelAlpha = 0;\n        // update cursor\n        this.updateMouseCursorType();\n\n        travelUseRotation = (targetOrientation instanceof THREE.Quaternion || targetOrientation instanceof THREE.Vector3);\n        travelUseSmooth = useSmooth;\n\n        // start position (current camera position)\n        travelStartPos.copy(this.camera.position);\n\n        // start rotation (current camera rotation)\n        travelStartRot.copy(this.camera.quaternion);\n\n        // setup the end rotation :\n\n        // case where targetOrientation is a quaternion\n        if (targetOrientation instanceof THREE.Quaternion) {\n            travelEndRot.copy(targetOrientation);\n        }\n        // case where targetOrientation is a vector3\n        else if (targetOrientation instanceof THREE.Vector3) {\n            if (targetPos === targetOrientation) {\n                this.camera.lookAt(targetOrientation);\n                travelEndRot.copy(this.camera.quaternion);\n                this.camera.quaternion.copy(travelStartRot);\n            }\n            else {\n                this.camera.position.copy(targetPos);\n                this.camera.lookAt(targetOrientation);\n                travelEndRot.copy(this.camera.quaternion);\n                this.camera.quaternion.copy(travelStartRot);\n                this.camera.position.copy(travelStartPos);\n            }\n        }\n\n        // end position\n        travelEndPos.copy(targetPos);\n\n        // beginning of the travel duration setup\n\n        if (this.instantTravel) {\n            travelDuration = 0;\n        }\n        // case where travelTime is set to 'auto' : travelDuration will be a value between autoTravelTimeMin and autoTravelTimeMax\n        // depending on travel distance and travel angular difference\n        else if (travelTime === 'auto') {\n            // a value between 0 and 1 according to the travel distance. Adjusted by autoTravelTimeDist parameter\n            const normalizedDistance = Math.min(1, targetPos.distanceTo(this.camera.position) / this.autoTravelTimeDist);\n\n            travelDuration = THREE.Math.lerp(this.autoTravelTimeMin, this.autoTravelTimeMax, normalizedDistance);\n\n            // if travel changes camera orientation, travel duration is adjusted according to angularDifference\n            // this allows for a smoother travel (more time for the camera to rotate)\n            // final duration will not excede autoTravelTimeMax\n            if (travelUseRotation) {\n                // value is normalized between 0 and 1\n                const angularDifference = 0.5 - 0.5 * (travelEndRot.normalize().dot(this.camera.quaternion.normalize()));\n\n                travelDuration *= 1 + 2 * angularDifference;\n                travelDuration = Math.min(travelDuration, this.autoTravelTimeMax);\n            }\n        }\n        // case where traveltime !== 'auto' : travelTime is a duration in seconds given as parameter\n        else {\n            travelDuration = travelTime;\n        }\n    };\n\n    /**\n    * Resume normal behavior after a travel is completed\n    */\n    this.endTravel = function endTravel() {\n        this.camera.position.copy(travelEndPos);\n\n        if (travelUseRotation) {\n            this.camera.quaternion.copy(travelEndRot);\n        }\n\n        this.state = STATE.NONE;\n\n        this.updateMouseCursorType();\n    };\n\n    /**\n    * Handle the animated movement and rotation of the camera in 'travel' state\n    * @param {number} dt : the deltatime between two updates in milliseconds\n    */\n    this.handleTravel = function handleTravel(dt) {\n        travelAlpha += (dt / 1000) / travelDuration;\n\n        // the animation alpha, between 0 (start) and 1 (finish)\n        const alpha = (travelUseSmooth) ? smooth(travelAlpha) : travelAlpha;\n\n        // new position\n        this.camera.position.lerpVectors(travelStartPos, travelEndPos, alpha);\n\n        // new rotation\n        if (travelUseRotation === true) {\n            THREE.Quaternion.slerp(travelStartRot, travelEndRot, this.camera.quaternion, alpha);\n        }\n        // completion test\n        if (travelAlpha > 1) {\n            this.endTravel();\n        }\n    };\n\n    /**\n    * Triggers an animated movement (travel) to set the camera to top view, above the focus point, at altitude=distanceToFocusPoint\n    */\n    this.goToTopView = function goToTopView() {\n        const topViewPos = new THREE.Vector3();\n        const targetQuat = new THREE.Quaternion();\n\n        // the top view position is above the camera focus point, at an altitude = distanceToPoint\n        topViewPos.copy(this.getWorldPointAtScreenXY({ x: 0.5 * this.domElement.clientWidth, y: 0.5 * this.domElement.clientHeight }));\n        topViewPos.z += Math.min(this.maxAltitude, this.camera.position.distanceTo(topViewPos));\n\n        targetQuat.setFromAxisAngle(new THREE.Vector3(1, 0, 0), 0);\n\n        // initiate the travel\n        this.initiateTravel(topViewPos, 'auto', targetQuat, true);\n    };\n\n    /**\n    * Triggers an animated movement (travel) to set the camera to starting view\n    */\n    this.goToStartView = function goToStartView() {\n        this.initiateTravel(startPosition, 'auto', startQuaternion, true);\n    };\n\n    /**\n    * returns the world point (xyz) under the posXY screen point\n    * the point belong to an abstract mathematical plane of specified altitude (doesnt use actual geometry)\n    * @param {THREE.Vector2} posXY : the mouse position in screen space (unit : pixel)\n    * @param {number} altitude : the altitude (z) of the mathematical plane\n    * @returns {THREE.Vector3}\n    */\n    this.getWorldPointFromMathPlaneAtScreenXY = (() => {\n        const vector = new THREE.Vector3();\n        return (posXY, altitude) => {\n            vector.set((posXY.x / this.domElement.clientWidth) * 2 - 1, -(posXY.y / this.domElement.clientHeight) * 2 + 1, 0.5);\n            vector.unproject(this.camera);\n            // dir = direction toward the point on the plane\n            const dir = vector.sub(this.camera.position).normalize();\n            // distance from camera to point on the plane\n            const distance = (altitude - this.camera.position.z) / dir.z;\n\n            return this.camera.position.clone().add(dir.multiplyScalar(distance));\n        };\n    })();\n\n    /**\n    * returns the world point (xyz) under the posXY screen point\n    * if geometry is under the cursor, the point in obtained with getPickingPositionFromDepth\n    * if no geometry is under the cursor, the point is obtained with getWorldPointFromMathPlaneAtScreenXY\n    * @param {THREE.Vector2} posXY : the mouse position in screen space (unit : pixel)\n    * @returns {THREE.Vector3}\n    */\n    this.getWorldPointAtScreenXY = function getWorldPointAtScreenXY(posXY) {\n        const pointUnderCursor = this.view.getPickingPositionFromDepth(posXY);\n        // check if there is valid geometry under cursor\n        if (pointUnderCursor) {\n            return pointUnderCursor;\n        }\n        // if not, we use the mathematical plane at altitude = groundLevel\n        else {\n            return this.getWorldPointFromMathPlaneAtScreenXY(posXY, this.groundLevel);\n        }\n    };\n\n    this.updateMousePositionAndDelta = function updateMousePositionAndDelta(event) {\n        mousePosition.set(event.clientX, event.clientY);\n\n        deltaMousePosition.copy(mousePosition).sub(lastMousePosition);\n\n        lastMousePosition.copy(mousePosition);\n    };\n\n    /**\n    * Adds all the input event listeners (activate the controls)\n    */\n    this.addInputListeners = function addInputListeners() {\n        this.domElement.addEventListener('keydown', _handlerOnKeyDown, true);\n        this.domElement.addEventListener('mousedown', _handlerOnMouseDown, false);\n        this.domElement.addEventListener('mouseup', _handlerOnMouseUp, false);\n        this.domElement.addEventListener('mousemove', _handlerOnMouseMove, false);\n        this.domElement.addEventListener('mousewheel', _handlerOnMouseWheel, false);\n        // For firefox\n        this.domElement.addEventListener('MozMousePixelScroll', _handlerOnMouseWheel, false);\n    };\n\n    /**\n    * removes all the input event listeners (desactivate the controls)\n    */\n    this.removeInputListeners = function removeInputListeners() {\n        this.domElement.removeEventListener('keydown', _handlerOnKeyDown, true);\n        this.domElement.removeEventListener('mousedown', _handlerOnMouseDown, false);\n        this.domElement.removeEventListener('mouseup', _handlerOnMouseUp, false);\n        this.domElement.removeEventListener('mousemove', _handlerOnMouseMove, false);\n        this.domElement.removeEventListener('mousewheel', _handlerOnMouseWheel, false);\n        // For firefox\n        this.domElement.removeEventListener('MozMousePixelScroll', _handlerOnMouseWheel, false);\n    };\n\n    /**\n    * update the cursor image according to the control state\n    */\n    this.updateMouseCursorType = function updateMouseCursorType() {\n        switch (this.state) {\n            case STATE.NONE:\n                this.domElement.style.cursor = 'auto';\n                break;\n            case STATE.DRAG:\n                this.domElement.style.cursor = 'move';\n                break;\n            case STATE.PAN:\n                this.domElement.style.cursor = 'cell';\n                break;\n            case STATE.TRAVEL:\n                this.domElement.style.cursor = 'wait';\n                break;\n            case STATE.ROTATE:\n                this.domElement.style.cursor = 'move';\n                break;\n            default:\n                break;\n        }\n    };\n\n    // event listeners for user input (to activate the controls)\n    this.addInputListeners();\n}\n// ===== end of PlanarControls constructor =====\n\n/**\n* Catch and manage the event when a touch on the mouse is down.\n* @param {event} event : the current event (mouse left button clicked or mouse wheel button actionned)\n*/\nvar onMouseDown = function onMouseDown(event) {\n    event.preventDefault();\n\n    if (this.state === STATE.TRAVEL) {\n        return;\n    }\n\n    this.updateMousePositionAndDelta(event);\n\n    if (event.button === mouseButtons.LEFTCLICK) {\n        if (event.ctrlKey) {\n            this.initiateRotation();\n        } else {\n            this.initiateDrag();\n        }\n    } else if (event.button === mouseButtons.MIDDLECLICK) {\n        this.initiateSmartZoom(event);\n    } else if (event.button === mouseButtons.RIGHTCLICK) {\n        this.initiatePan();\n    }\n\n    this.updateMouseCursorType();\n};\n\n/**\n* Catch the event when a touch on the mouse is uped.\n* @param {event} event : the current event\n*/\nvar onMouseUp = function onMouseUp(event) {\n    event.preventDefault();\n\n    if (this.state !== STATE.TRAVEL) {\n        this.state = STATE.NONE;\n    }\n\n    this.updateMouseCursorType();\n};\n\n/**\n* Catch and manage the event when the mouse is moved\n* @param {event} event : the current event\n*/\nvar onMouseMove = function onMouseMove(event) {\n    event.preventDefault();\n\n    this.updateMousePositionAndDelta(event);\n\n    // notify change if moving\n    if (this.state !== STATE.NONE) {\n        this.view.notifyChange(true);\n    }\n};\n\n/**\n* Catch and manage the event when a key is down.\n* @param {event} event : the current event\n*/\nvar onKeyDown = function onKeyDown(event) {\n    if (this.state === STATE.TRAVEL) {\n        return;\n    }\n    if (event.keyCode === keys.T) {\n        this.goToTopView();\n    }\n    if (event.keyCode === keys.Y) {\n        this.goToStartView();\n    }\n    if (event.keyCode === keys.SPACE) {\n        this.initiateSmartZoom(event);\n    }\n};\n\n/**\n* Catch and manage the event when the mouse wheel is rolled.\n* @param {event} event : the current event\n*/\nvar onMouseWheel = function onMouseWheel(event) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (this.state === STATE.NONE) {\n        this.initiateZoom(event);\n    }\n};\n\n/**\n* Catch and manage the event when the context menu is called (by a right click on the window).\n* We use this to prevent the context menu from appearing, so we can use right click for other inputs.\n* @param {event} event : the current event\n*/\nvar onContextMenu = function onContextMenu(event) {\n    event.preventDefault();\n};\n\n/**\n* smoothing function (sigmoid) : based on h01 Hermite function\n* returns a value between 0 and 1\n* @param {number} value : the value to be smoothed, between 0 and 1\n* @returns {number}\n*/\nvar smooth = function smooth(value) {\n    // p between 1.0 and 1.5 (empirical)\n    const p = 1.20;\n    return Math.pow((value * value * (3 - 2 * value)), p);\n};\n\nexport default PlanarControls;\n"]}