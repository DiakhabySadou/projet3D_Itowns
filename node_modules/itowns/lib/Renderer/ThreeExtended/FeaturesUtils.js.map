{"version":3,"sources":["../../../src/Renderer/ThreeExtended/FeaturesUtils.js"],"names":["pointIsOverLine","point","linePoints","epsilon","x0","_values","y0","i","j","length","x1","y1","x2","y2","x21","y21","norm","Math","sqrt","scalar","distance","abs","getClosestPoint","points","squaredEpsilon","closestPoint","xP","yP","n","pointIsInsidePolygon","polygonPoints","x","y","inside","xi","yi","xj","yj","isFeatureUnderCoordinate","coordinate","type","coordinates","filterFeaturesUnderCoordinate","features","result","geometries","extent","isPointInside","feature","id","featureVertices","polygon","properties","slice","offset","count","under","push","geometry"],"mappings":"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","file":"FeaturesUtils.js","sourcesContent":["function pointIsOverLine(point, linePoints, epsilon) {\n    const x0 = point._values[0];\n    const y0 = point._values[1];\n    // for each segment of the line (j is i -1)\n    for (var i = 1, j = 0; i < linePoints.length; j = i++) {\n        /* **********************************************************\n            norm     : norm of vector P1P2\n            distance : distance point P0 to line P1P2\n            scalar   : dot product of P1P0 and P1P2 divide by norm, it represents the projection of P0 on the line\n\n            Point is over segment P1P2 if :\n                * if the distance, , is inferior to epsilon\n                * and if :  -epsilon ≤ scalar ≤ (||P1P2|| +  epsilon)\n\n                            + (P0) _\n                            |      |\n                            |      |\n             <---scalar---->|    distance\n                            |      |\n                            |      v\n             +-------------------------------+\n            (P1)                            (P2)\n        *********************************************************** */\n\n        const x1 = linePoints[i]._values[0];\n        const y1 = linePoints[i]._values[1];\n        const x2 = linePoints[j]._values[0];\n        const y2 = linePoints[j]._values[1];\n\n        const Xp = x0 - x1;\n        const Yp = y0 - y1;\n\n        const x21 = x2 - x1;\n        const y21 = y2 - y1;\n        const norm = Math.sqrt(x21 * x21 + y21 * y21);\n        const scalar = (Xp * x21 + Yp * y21) / norm;\n\n        if (scalar >= -epsilon && scalar <= norm + epsilon) {\n            const distance = Math.abs(y21 * x0 - x21 * y0 + x2 * y1 - y2 * x1) / norm;\n            if (distance <= epsilon) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction getClosestPoint(point, points, epsilon) {\n    const x0 = point._values[0];\n    const y0 = point._values[1];\n    let squaredEpsilon = epsilon * epsilon;\n    let closestPoint;\n    for (var i = 0; i < points.length; ++i) {\n        const x1 = points[i]._values[0];\n        const y1 = points[i]._values[1];\n        const xP = x0 - x1;\n        const yP = y0 - y1;\n        const n = xP * xP + yP * yP;\n        if (n < squaredEpsilon) {\n            closestPoint = points[i];\n            squaredEpsilon = n;\n        }\n    }\n    return closestPoint;\n}\n\nfunction pointIsInsidePolygon(point, polygonPoints) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n\n    const x = point._values[0];\n    const y = point._values[1];\n\n    let inside = false;\n    // in first j is last point of polygon\n    // for each segment of the polygon (j is i -1)\n    for (let i = 0, j = polygonPoints.length - 1; i < polygonPoints.length; j = i++) {\n        const xi = polygonPoints[i]._values[0];\n        const yi = polygonPoints[i]._values[1];\n        const xj = polygonPoints[j]._values[0];\n        const yj = polygonPoints[j]._values[1];\n\n        // isIntersect semi-infinite ray horizontally with polygon's edge\n        const isIntersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (isIntersect) {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n}\n\nfunction isFeatureUnderCoordinate(coordinate, type, coordinates, epsilon) {\n    if (type == 'linestring' && pointIsOverLine(coordinate, coordinates, epsilon)) {\n        return true;\n    } else if (type == 'polygon' && pointIsInsidePolygon(coordinate, coordinates)) {\n        return true;\n    } else if (type == 'point') {\n        const closestPoint = getClosestPoint(coordinate, coordinates, epsilon);\n        if (closestPoint) {\n            return { coordinates: closestPoint };\n        }\n    }\n}\n\nexport default {\n    /**\n     * filters the features that are under the coordinate\n     *\n     * @param      {Coordinates}  coordinate  the coordinate for the filter condition\n     * @param      {Features}  features  features to filter\n     * @param      {number}  epsilon  tolerance around the coordinate (in coordinate's unit)\n     * @return     {array}  array of filters features\n     */\n    filterFeaturesUnderCoordinate(coordinate, features, epsilon = 0.1) {\n        const result = [];\n        if (features.geometries) {\n            if (features.extent && !features.extent.isPointInside(coordinate, epsilon)) {\n                return result;\n            }\n            for (const feature of features.geometries) {\n                if (feature.extent && !feature.extent.isPointInside(coordinate, epsilon)) {\n                    continue;\n                }\n                /* eslint-disable guard-for-in */\n                for (const id in feature.featureVertices) {\n                    const polygon = feature.featureVertices[id];\n                    if (polygon.extent && !polygon.extent.isPointInside(coordinate, epsilon)) {\n                        continue;\n                    }\n                    const properties = features.features[id].properties;\n                    const coordinates = feature.coordinates.slice(polygon.offset, polygon.offset + polygon.count);\n                    const under = isFeatureUnderCoordinate(coordinate, feature.type, coordinates, epsilon);\n                    if (under) {\n                        result.push({\n                            coordinates: under.coordinates || coordinates,\n                            type: feature.type,\n                            properties,\n                        });\n                    }\n                }\n            }\n        } else if (features.geometry) {\n            if (features.geometry.extent && !features.geometry.extent.isPointInside(coordinate, epsilon)) {\n                return result;\n            }\n            const under = isFeatureUnderCoordinate(coordinate, features.geometry.type, features.geometry.coordinates, epsilon);\n            if (under) {\n                result.push({\n                    coordinates: under.coordinates || features.geometry.coordinates,\n                    type: features.geometry.type,\n                    properties: features.properties,\n                });\n            }\n        }\n        return result;\n    },\n};\n"]}