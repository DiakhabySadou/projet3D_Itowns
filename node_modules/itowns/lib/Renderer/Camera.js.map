{"version":3,"sources":["../../src/Renderer/Camera.js"],"names":["THREE","Camera","crs","width","height","options","Object","defineProperty","get","camera3D","camera","PerspectiveCamera","_viewMatrix","Matrix4","resize","ratio","aspect","isOrthographicCamera","halfH","right","left","y","top","bottom","updateProjectionMatrix","prototype","update","updateMatrixWorld","multiplyMatrices","projectionMatrix","matrixWorldInverse","position","as","setPosition","copy","xyz","tmp","frustum","Frustum","matrix","box3","Box3","isBox3Visible","matrixWorld","setFromMatrix","intersectsBox","isSphereVisible","sphere","intersectsSphere","box3SizeOnScreen","applyMatrix4","adjustAltitudeToAvoidCollisionWithLayer","view","elevationLayer","minDistanceCollision","camLocation","undefined","elevationUnderCamera","getElevationValueAt","difElevation","altitude","z","setAltitude","referenceCrs","notifyChange"],"mappings":"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","file":"Camera.js","sourcesContent":["/**\n * Wrapper around three.js camera to expose some geographic helpers.\n */\n\nimport * as THREE from 'three';\nimport Coordinates from '../Core/Geographic/Coordinates';\nimport DEMUtils from '../utils/DEMUtils';\n\nfunction Camera(crs, width, height, options = {}) {\n    Object.defineProperty(this, 'crs', { get: () => crs });\n\n    this.camera3D = options.camera ? options.camera : new THREE.PerspectiveCamera(30, width / height);\n\n    this._viewMatrix = new THREE.Matrix4();\n    this.width = width;\n    this.height = height;\n}\n\nfunction resize(camera, width, height) {\n    camera.width = width;\n    camera.height = height;\n    const ratio = width / height;\n\n    if (camera.camera3D.aspect !== ratio) {\n        camera.camera3D.aspect = ratio;\n        if (camera.camera3D.isOrthographicCamera) {\n            const halfH = (camera.camera3D.right - camera.camera3D.left) * 0.5 / ratio;\n            const y = (camera.camera3D.top + camera.camera3D.bottom) * 0.5;\n            camera.camera3D.top = y + halfH;\n            camera.camera3D.bottom = y - halfH;\n        }\n    }\n\n    if (camera.camera3D.updateProjectionMatrix) {\n        camera.camera3D.updateProjectionMatrix();\n    }\n}\n\nCamera.prototype.update = function update(width, height) {\n    resize(this, width, height);\n\n    // update matrix\n    this.camera3D.updateMatrixWorld();\n\n    // keep our visibility testing matrix ready\n    this._viewMatrix.multiplyMatrices(this.camera3D.projectionMatrix, this.camera3D.matrixWorldInverse);\n};\n\n/**\n * Return the position in the requested CRS, or in camera's CRS if undefined.\n * @param {string} crs if defined (e.g 'EPSG:4236') the camera position will be returned in this CRS\n * @return {Coordinates} Coordinates object holding camera's position\n */\nCamera.prototype.position = function position(crs) {\n    return new Coordinates(this.crs, this.camera3D.position).as(crs || this.crs);\n};\n\n/**\n * Set the position of the camera using a Coordinates object.\n * If you want to modify the position directly using x,y,z value then use camera.camera3D.position.set(x, y, z)\n * @param {Coordinates} position the new position of the camera\n */\nCamera.prototype.setPosition = function setPosition(position) {\n    this.camera3D.position.copy(position.as(this.crs).xyz());\n};\n\nconst tmp = {\n    frustum: new THREE.Frustum(),\n    matrix: new THREE.Matrix4(),\n    box3: new THREE.Box3(),\n};\n\nCamera.prototype.isBox3Visible = function isBox3Visible(box3, matrixWorld) {\n    if (matrixWorld) {\n        tmp.matrix.multiplyMatrices(this._viewMatrix, matrixWorld);\n        tmp.frustum.setFromMatrix(tmp.matrix);\n    } else {\n        tmp.frustum.setFromMatrix(this._viewMatrix);\n    }\n    return tmp.frustum.intersectsBox(box3);\n};\n\nCamera.prototype.isSphereVisible = function isSphereVisible(sphere, matrixWorld) {\n    if (matrixWorld) {\n        tmp.matrix.multiplyMatrices(this._viewMatrix, matrixWorld);\n        tmp.frustum.setFromMatrix(tmp.matrix);\n    } else {\n        tmp.frustum.setFromMatrix(this._viewMatrix);\n    }\n    return tmp.frustum.intersectsSphere(sphere);\n};\n\nCamera.prototype.box3SizeOnScreen = function box3SizeOnScreen(box3, matrixWorld) {\n    tmp.box3.copy(box3);\n\n    if (matrixWorld) {\n        tmp.matrix.multiplyMatrices(this._viewMatrix, matrixWorld);\n        tmp.box3.applyMatrix4(tmp.matrix);\n    } else {\n        tmp.box3.applyMatrix4(this._viewMatrix);\n    }\n    return tmp.box3;\n};\n\n /**\n * Test for collision between camera and a geometry layer (DTM/DSM) to adjust camera position\n * It could be modified later to handle an array of geometry layers\n * TODO Improve Coordinates class to handle altitude for any coordinate system (even projected one)\n * @param {view} view where we test the collision between geometry layers and the camera\n * @param {elevationLayer} elevationLayer (DTM/DSM) used to test the collision with the camera. Could be another geometry layer\n * @param {minDistanceCollision} minDistanceCollision the minimum distance allowed between the camera and the surface\n */\nCamera.prototype.adjustAltitudeToAvoidCollisionWithLayer = function adjustAltitudeToAvoidCollisionWithLayer(view, elevationLayer, minDistanceCollision) {\n    // We put the camera location in geographic by default to easily handle altitude. (Should be improved in Coordinates class for all ref)\n    const camLocation = view.camera.position().as('EPSG:4326');\n    if (elevationLayer !== undefined) {\n        const elevationUnderCamera = DEMUtils.getElevationValueAt(elevationLayer, camLocation);\n        if (elevationUnderCamera != undefined) {\n            const difElevation = camLocation.altitude() - (elevationUnderCamera.z + minDistanceCollision);\n            // We move the camera to avoid collisions if too close to terrain\n            if (difElevation < 0) {\n                camLocation.setAltitude(elevationUnderCamera.z + minDistanceCollision);\n                view.camera.camera3D.position.copy(camLocation.as(view.referenceCrs).xyz());\n                view.notifyChange(true);\n            }\n        }\n    }\n};\n\nexport default Camera;\n"]}